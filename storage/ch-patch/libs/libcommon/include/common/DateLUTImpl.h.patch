diff --git a/libs/libcommon/include/common/DateLUTImpl.h b/libs/libcommon/include/common/DateLUTImpl.h
index 535c863eeb3e..daa1e6db9d7c 100644
--- a/libs/libcommon/include/common/DateLUTImpl.h
+++ b/libs/libcommon/include/common/DateLUTImpl.h
@@ -1,21 +1,28 @@
 #pragma once
 
+#include <Poco/Exception.h>
+#include <boost/date_time/gregorian/gregorian.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/date_time/local_time/local_time.hpp>
+#include <boost/date_time/time_clock.hpp>
+
 #include <common/Types.h>
 #include <common/likely.h>
 #include <common/strong_typedef.h>
 
 #include <ctime>
 
-#define DATE_LUT_MAX (0xFFFFFFFFU - 86400)
-#define DATE_LUT_MAX_DAY_NUM (0xFFFFFFFFU / 86400)
+#define DATE_LUT_MAX (0xFFFFFFFFFFFFFFFLL - 86400)
+#define DATE_LUT_MIN -30610224000LL
+#define DATE_LUT_MAX_DAY_NUM 36500000
 /// Table size is bigger than DATE_LUT_MAX_DAY_NUM to fill all indices within UInt16 range: this allows to remove extra check.
-#define DATE_LUT_SIZE 0x10000
-#define DATE_LUT_MIN_YEAR 1970
-#define DATE_LUT_MAX_YEAR 2105 /// Last supported year
+#define DATE_LUT_SIZE 36652424
+#define DATE_LUT_MIN_YEAR 1400 
+#define DATE_LUT_MAX_YEAR 9999 /// Last supported year
 #define DATE_LUT_YEARS (1 + DATE_LUT_MAX_YEAR - DATE_LUT_MIN_YEAR) /// Number of years in lookup table
 
 
-STRONG_TYPEDEF(UInt16, DayNum_t);
+STRONG_TYPEDEF(UInt32, DayNum_t);
 
 
 /** Lookup table to conversion of time to date, and to month / year / day of week / day of month and so on.
@@ -23,8 +30,29 @@ STRONG_TYPEDEF(UInt16, DayNum_t);
   */
 class DateLUTImpl
 {
+    using Exception = Poco::Exception;
+    using DateType = boost::gregorian::date;
+    using DurationType = boost::posix_time::time_duration;
+    using ptime = boost::posix_time::ptime;
+    using TzPtr = boost::local_time::time_zone_ptr;
+    using ltime = boost::local_time::local_date_time;
+
+    TzPtr zone;
+    UInt32 start_day_num;
+    
 public:
-    DateLUTImpl(const std::string & time_zone);
+    DateLUTImpl(const std::string &){
+        DurationType utc_offset(boost::date_time::second_clock<ptime>::local_time() - boost::date_time::second_clock<ptime>::universal_time());
+        std::ostringstream ss;
+        if (!utc_offset.is_negative()) {
+            ss << "UTC+"<< utc_offset;
+        } else {
+            ss << "UTC" << utc_offset;
+        }
+        time_zone = ss.str();
+        zone = TzPtr(new boost::local_time::posix_time_zone(time_zone));
+        start_day_num = DateType(1400,1,1).day_count().as_number();
+    };
 
 public:
     struct Values
@@ -32,7 +60,7 @@ public:
         /// Least significat 32 bits from time_t at beginning of the day.
         /// If the unix timestamp of beginning of the day is negative (example: 1970-01-01 MSK, where time_t == -10800), then value is zero.
         /// Change to time_t; change constants above; and recompile the sources if you need to support time after 2105 year.
-        UInt32 date;
+        time_t date;
 
         /// Properties of the day.
         UInt16 year;
@@ -54,206 +82,258 @@ private:
     /// Day nums are the same in all time zones. 1970-01-01 is 0 and so on.
     /// Table is relatively large, so better not to place the object on stack.
     /// In comparison to std::vector, plain array is cheaper by one indirection.
-    Values lut[DATE_LUT_SIZE];
+    //Values lut[DATE_LUT_SIZE];
 
     /// Year number after DATE_LUT_MIN_YEAR -> day num for start of year.
-    DayNum_t years_lut[DATE_LUT_YEARS];
+    //DayNum_t years_lut[DATE_LUT_YEARS];
 
     /// Year number after DATE_LUT_MIN_YEAR * month number starting at zero -> day num for first day of month
-    DayNum_t years_months_lut[DATE_LUT_YEARS * 12];
+    //DayNum_t years_months_lut[DATE_LUT_YEARS * 12];
 
     /// UTC offset at beginning of the Unix epoch. The same as unix timestamp of 1970-01-01 00:00:00 local time.
-    time_t offset_at_start_of_epoch;
-    bool offset_is_whole_number_of_hours_everytime;
+    //time_t offset_at_start_of_epoch;
+    //bool offset_is_whole_number_of_hours_everytime;
 
     /// Time zone name.
     std::string time_zone;
 
 
     /// We can correctly process only timestamps that less DATE_LUT_MAX (i.e. up to 2105 year inclusively)
-    inline size_t findIndex(time_t t) const
-    {
-        /// First guess.
-        size_t guess = t / 86400;
-        if (guess >= DATE_LUT_MAX_DAY_NUM)
-            return 0;
-        if (t >= lut[guess].date && t < lut[guess + 1].date)
-            return guess;
-
-        for (size_t i = 1;; ++i)
-        {
-            if (guess + i >= DATE_LUT_MAX_DAY_NUM)
-                return 0;
-            if (t >= lut[guess + i].date && t < lut[guess + i + 1].date)
-                return guess + i;
-            if (guess < i)
-                return 0;
-            if (t >= lut[guess - i].date && t < lut[guess - i + 1].date)
-                return guess - i;
-        }
-    }
-
-    inline const Values & find(time_t t) const
-    {
-        return lut[findIndex(t)];
-    }
+    //inline size_t findIndex(time_t /*t*/) const
+    //{
+    //    /// First guess.
+    //    size_t guess = (t - DATE_LUT_MIN) / 86400;
+    //    if (guess >= DATE_LUT_MAX_DAY_NUM)
+    //        return 0;
+    //    if (t >= lut[guess].date && t < lut[guess + 1].date)
+    //        return guess;
+
+    //    for (size_t i = 1;; ++i)
+    //    {
+    //        if (guess + i >= DATE_LUT_MAX_DAY_NUM)
+    //            return 0;
+    //        if (t >= lut[guess + i].date && t < lut[guess + i + 1].date)
+    //            return guess + i;
+    //        if (guess < i)
+    //            return 0;
+    //        if (t >= lut[guess - i].date && t < lut[guess - i + 1].date)
+    //            return guess - i;
+    //    }
+    //}
+
+    //inline const Values & find(time_t /*t*/) const
+    //{
+    //    return lut[findIndex(/*t*/)];
+    //}
 
 public:
     const std::string & getTimeZone() const { return time_zone; }
 
     /// All functions below are thread-safe; arguments are not checked.
 
-    inline time_t toDate(time_t t) const { return find(t).date; }
-    inline unsigned toMonth(time_t t) const { return find(t).month; }
-    inline unsigned toQuarter(time_t t) const { return (find(t).month - 1) / 3 + 1; }
-    inline unsigned toYear(time_t t) const { return find(t).year; }
-    inline unsigned toDayOfWeek(time_t t) const { return find(t).day_of_week; }
-    inline unsigned toDayOfMonth(time_t t) const { return find(t).day_of_month; }
+    inline time_t toDate(time_t /*t*/) const { 
+          std::cout<<__LINE__<<std::endl;
+          throw Exception("Not Implement yet");
+    //    return find(/*t*/).date; 
+    }
+    inline unsigned toMonth(time_t /*t*/) const {
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return find(/*t*/).month; 
+    }
+    inline unsigned toQuarter(time_t /*t*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return (find(/*t*/).month - 1) / 3 + 1; 
+    }
+    inline unsigned toYear(time_t /*t*/) const {
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return find(/*t*/).year; 
+    }
+    inline unsigned toDayOfWeek(time_t /*t*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return find(/*t*/).day_of_week; 
+    }
+    inline unsigned toDayOfMonth(time_t /*t*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return find(/*t*/).day_of_month; 
+    }
 
     /// Round down to start of monday.
-    inline time_t toFirstDayOfWeek(time_t t) const
+    inline time_t toFirstDayOfWeek(time_t /*t*/) const
     {
-        size_t index = findIndex(t);
-        return lut[index - (lut[index].day_of_week - 1)].date;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //size_t index = findIndex(/*t*/);
+        //return lut[index - (lut[index].day_of_week - 1)].date;
     }
 
-    inline DayNum_t toFirstDayNumOfWeek(DayNum_t d) const
+    inline DayNum_t toFirstDayNumOfWeek(DayNum_t /*d*/) const
     {
-        return DayNum_t(d - (lut[d].day_of_week - 1));
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return DayNum_t(d - (lut[d].day_of_week - 1));
     }
 
-    inline DayNum_t toFirstDayNumOfWeek(time_t t) const
+    inline DayNum_t toFirstDayNumOfWeek(time_t /*t*/) const
     {
-        return toFirstDayNumOfWeek(toDayNum(t));
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return toFirstDayNumOfWeek(toDayNum(/*t*/));
     }
 
     /// Round down to start of month.
-    inline time_t toFirstDayOfMonth(time_t t) const
+    inline time_t toFirstDayOfMonth(time_t /*t*/) const
     {
-        size_t index = findIndex(t);
-        return lut[index - (lut[index].day_of_month - 1)].date;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //size_t index = findIndex(/*t*/);
+        //return lut[index - (lut[index].day_of_month - 1)].date;
     }
 
     inline DayNum_t toFirstDayNumOfMonth(DayNum_t d) const
     {
-        return DayNum_t(d - (lut[d].day_of_month - 1));
+        DateType dt = DateType(DateType::date_rep_type(d + start_day_num));
+        DateType newDt = DateType(dt.year() , dt.month(), 1);
+        return DayNum_t(newDt.day_count().as_number() - start_day_num);
     }
 
-    inline DayNum_t toFirstDayNumOfMonth(time_t t) const
+    inline DayNum_t toFirstDayNumOfMonth(time_t /*t*/) const
     {
-        return toFirstDayNumOfMonth(toDayNum(t));
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return toFirstDayNumOfMonth(toDayNum(/*t*/));
     }
 
     /// Round down to start of quarter.
-    inline DayNum_t toFirstDayNumOfQuarter(DayNum_t d) const
+    inline DayNum_t toFirstDayNumOfQuarter(DayNum_t /*d*/) const
     {
-        size_t index = d;
-        size_t month_inside_quarter = (lut[index].month - 1) % 3;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //size_t index = d;
+        //size_t month_inside_quarter = (lut[index].month - 1) % 3;
 
-        index = index - lut[index].day_of_month;
-        while (month_inside_quarter)
-        {
-            index = index - lut[index].day_of_month;
-            --month_inside_quarter;
-        }
+        //index = index - lut[index].day_of_month;
+        //while (month_inside_quarter)
+        //{
+        //    index = index - lut[index].day_of_month;
+        //    --month_inside_quarter;
+        //}
 
-        return DayNum_t(index + 1);
+        //return DayNum_t(index + 1);
     }
 
-    inline DayNum_t toFirstDayNumOfQuarter(time_t t) const
+    inline DayNum_t toFirstDayNumOfQuarter(time_t /*t*/) const
     {
-        return toFirstDayNumOfQuarter(toDayNum(t));
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return toFirstDayNumOfQuarter(toDayNum(/*t*/));
     }
 
-    inline time_t toFirstDayOfQuarter(time_t t) const
+    inline time_t toFirstDayOfQuarter(time_t /*t*/) const
     {
-        return fromDayNum(toFirstDayNumOfQuarter(t));
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return fromDayNum(toFirstDayNumOfQuarter(/*t*/));
     }
 
     /// Round down to start of year.
-    inline time_t toFirstDayOfYear(time_t t) const
+    inline time_t toFirstDayOfYear(time_t /*t*/) const
     {
-        return lut[years_lut[lut[findIndex(t)].year - DATE_LUT_MIN_YEAR]].date;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return lut[years_lut[lut[findIndex(/*t*/)].year - DATE_LUT_MIN_YEAR]].date;
     }
 
-    inline DayNum_t toFirstDayNumOfYear(DayNum_t d) const
+    inline DayNum_t toFirstDayNumOfYear(DayNum_t /*d*/) const
     {
-        return years_lut[lut[d].year - DATE_LUT_MIN_YEAR];
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return years_lut[lut[d].year - DATE_LUT_MIN_YEAR];
     }
 
-    inline DayNum_t toFirstDayNumOfYear(time_t t) const
+    inline DayNum_t toFirstDayNumOfYear(time_t /*t*/) const
     {
-        return toFirstDayNumOfYear(toDayNum(t));
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return toFirstDayNumOfYear(toDayNum(/*t*/));
     }
 
-    inline time_t toFirstDayOfNextMonth(time_t t) const
+    inline time_t toFirstDayOfNextMonth(time_t /*t*/) const
     {
-        size_t index = findIndex(t);
-        index += 32 - lut[index].day_of_month;
-        return lut[index - (lut[index].day_of_month - 1)].date;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //size_t index = findIndex(/*t*/);
+        //index += 32 - lut[index].day_of_month;
+        //return lut[index - (lut[index].day_of_month - 1)].date;
     }
 
-    inline time_t toFirstDayOfPrevMonth(time_t t) const
+    inline time_t toFirstDayOfPrevMonth(time_t /*t*/) const
     {
-        size_t index = findIndex(t);
-        index -= lut[index].day_of_month;
-        return lut[index - (lut[index].day_of_month - 1)].date;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //size_t index = findIndex(/*t*/);
+        //index -= lut[index].day_of_month;
+        //return lut[index - (lut[index].day_of_month - 1)].date;
     }
 
-    inline UInt8 daysInMonth(DayNum_t d) const
+    inline UInt8 daysInMonth(DayNum_t /*d*/) const
     {
-        return lut[d].days_in_month;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return lut[d].days_in_month;
     }
 
-    inline UInt8 daysInMonth(time_t t) const
+    inline UInt8 daysInMonth(time_t /*t*/) const
     {
-        return find(t).days_in_month;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return find(/*t*/).days_in_month;
     }
 
-    inline UInt8 daysInMonth(UInt16 year, UInt8 month) const
+    inline UInt8 daysInMonth(UInt16, UInt8) const
     {
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
         /// 32 makes arithmetic more simple.
-        auto any_day_of_month = years_lut[year - DATE_LUT_MIN_YEAR] + 32 * (month - 1);
-        return lut[any_day_of_month].days_in_month;
+        //auto any_day_of_month = years_lut[year - DATE_LUT_MIN_YEAR] + 32 * (month - 1);
+        //return lut[any_day_of_month].days_in_month;
     }
 
     /** Round to start of day, then shift for specified amount of days.
       */
-    inline time_t toDateAndShift(time_t t, Int32 days) const
+    inline time_t toDateAndShift(time_t, Int32 ) const
     {
-        return lut[findIndex(t) + days].date;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return lut[findIndex(/*t*/) + days].date;
     }
 
-    inline time_t toTime(time_t t) const
+    inline time_t toTime(time_t /*t*/) const
     {
-        size_t index = findIndex(t);
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //size_t index = findIndex(/*t*/);
 
-        if (unlikely(index == 0))
-            return t + offset_at_start_of_epoch;
+        //if (unlikely(index == 0))
+        //    return t + offset_at_start_of_epoch;
 
-        time_t res = t - lut[index].date;
+        //time_t res = t - lut[index].date;
 
-        if (res >= lut[index].time_at_offset_change)
-            res += lut[index].amount_of_offset_change;
+        //if (res >= lut[index].time_at_offset_change)
+        //    res += lut[index].amount_of_offset_change;
 
-        return res - offset_at_start_of_epoch; /// Starting at 1970-01-01 00:00:00 local time.
+        //return res - offset_at_start_of_epoch; /// Starting at 1000-01-01 00:00:00 local time.
     }
 
     inline unsigned toHour(time_t t) const
     {
-        size_t index = findIndex(t);
-
-        /// If it is not 1970 year (findIndex found nothing appropriate),
-        ///  than limit number of hours to avoid insane results like 1970-01-01 89:28:15
-        if (unlikely(index == 0))
-            return static_cast<unsigned>((t + offset_at_start_of_epoch) / 3600) % 24;
-
-        time_t res = t - lut[index].date;
-
-        if (res >= lut[index].time_at_offset_change)
-            res += lut[index].amount_of_offset_change;
-
-        return res / 3600;
+        ptime tm = boost::posix_time::from_time_t(t);
+        ltime lm (tm, zone);
+        return lm.local_time().time_of_day().hours();
     }
 
     /** Only for time zones with/when offset from UTC is multiple of five minutes.
@@ -267,29 +347,57 @@ public:
       *  each minute, with added or subtracted leap second, spans exactly 60 unix timestamps.
       */
 
-    inline unsigned toSecond(time_t t) const { return t % 60; }
+    inline unsigned toSecond(time_t t) const 
+    {
+        //size_t index = findIndex(/*t*/);
+
+        ///// If it is not 1970 year (findIndex found nothing appropriate),
+        /////  than limit number of hours to avoid insane results like 1970-01-01 89:28:15
+        //if (unlikely(index == 0))
+        //    return static_cast<unsigned>((t + offset_at_start_of_epoch) / 3600) % 24;
+
+        //time_t res = t - lut[index].date;
+
+        //if (res >= lut[index].time_at_offset_change)
+        //    res += lut[index].amount_of_offset_change;
+        ptime tm = boost::posix_time::from_time_t(t);
+        ltime lm (tm, zone);
+        return lm.local_time().time_of_day().seconds();
+    }
 
     inline unsigned toMinute(time_t t) const
     {
-        if (offset_is_whole_number_of_hours_everytime)
-            return (t / 60) % 60;
-
-        time_t date = find(t).date;
-        return (t - date) / 60 % 60;
+        ptime tm = boost::posix_time::from_time_t(t);
+        ltime lm (tm, zone);
+        return lm.local_time().time_of_day().minutes();
     }
 
-    inline time_t toStartOfMinute(time_t t) const { return t / 60 * 60; }
-    inline time_t toStartOfFiveMinute(time_t t) const { return t / 300 * 300; }
-    inline time_t toStartOfFifteenMinutes(time_t t) const { return t / 900 * 900; }
+    inline time_t toStartOfMinute(time_t /*t*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return t / 60 * 60; 
+    }
+    inline time_t toStartOfFiveMinute(time_t /*t*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return t / 300 * 300; 
+    }
+    inline time_t toStartOfFifteenMinutes(time_t /*t*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return t / 900 * 900; 
+    }
 
-    inline time_t toStartOfHour(time_t t) const
+    inline time_t toStartOfHour(time_t /*t*/) const
     {
-        if (offset_is_whole_number_of_hours_everytime)
-            return t / 3600 * 3600;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //if (offset_is_whole_number_of_hours_everytime)
+        //    return t / 3600 * 3600;
 
-        time_t date = find(t).date;
-        /// Still can return wrong values for time at 1970-01-01 if the UTC offset was non-whole number of hours.
-        return date + (t - date) / 3600 * 3600;
+        //time_t date = find(/*t*/).date;
+        ///// Still can return wrong values for time at 1970-01-01 if the UTC offset was non-whole number of hours.
+        //return date + (t - date) / 3600 * 3600;
     }
 
     /** Number of calendar day since the beginning of UNIX epoch (1970-01-01 is zero)
@@ -300,75 +408,129 @@ public:
       *  because the same calendar day starts/ends at different timestamps in different time zones)
       */
 
-    inline DayNum_t toDayNum(time_t t) const { return static_cast<DayNum_t>(findIndex(t)); }
-    inline time_t fromDayNum(DayNum_t d) const { return lut[d].date; }
+    inline DayNum_t toDayNum(time_t t) const { 
+        ptime tm = boost::posix_time::from_time_t(t);
+        ltime lm (tm, zone);
+        DateType dt = lm.date();
+        return DayNum_t(dt.day_count().as_number()-start_day_num);
+    }
+    inline time_t fromDayNum(DayNum_t d) const { 
+        DateType dt = DateType(DateType::date_rep_type(d + start_day_num));
+        ltime lm (ptime(dt, DurationType()), zone);
+        ptime pt = lm.local_time();
+        return boost::posix_time::to_time_t(pt);
+    }
 
-    inline time_t toDate(DayNum_t d) const { return lut[d].date; }
-    inline unsigned toMonth(DayNum_t d) const { return lut[d].month; }
-    inline unsigned toQuarter(DayNum_t d) const { return (lut[d].month - 1) / 3 + 1; }
-    inline unsigned toYear(DayNum_t d) const { return lut[d].year; }
-    inline unsigned toDayOfWeek(DayNum_t d) const { return lut[d].day_of_week; }
-    inline unsigned toDayOfMonth(DayNum_t d) const { return lut[d].day_of_month; }
+    inline time_t toDate(DayNum_t /*d*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return lut[d].date; 
+    }
+    inline unsigned toMonth(DayNum_t /*d*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return lut[d].month; 
+    }
+    inline unsigned toQuarter(DayNum_t /*d*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return (lut[d].month - 1) / 3 + 1; 
+    }
+    inline unsigned toYear(DayNum_t /*d*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return lut[d].year; 
+    }
+    inline unsigned toDayOfWeek(DayNum_t /*d*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return lut[d].day_of_week; 
+    }
+    inline unsigned toDayOfMonth(DayNum_t /*d*/) const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return lut[d].day_of_month; 
+    }
 
     /// Number of week from some fixed moment in the past. Week begins at monday.
     /// (round down to monday and divide DayNum by 7; we made an assumption,
     ///  that in domain of the function there was no weeks with any other number of days than 7)
-    inline unsigned toRelativeWeekNum(DayNum_t d) const
+    inline unsigned toRelativeWeekNum(DayNum_t /*d*/) const
     {
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
         /// We add 8 to avoid underflow at beginning of unix epoch.
-        return (d + 8 - lut[d].day_of_week) / 7;
+        //return (d + 8 - lut[d].day_of_week) / 7;
     }
 
-    inline unsigned toRelativeWeekNum(time_t t) const
+    inline unsigned toRelativeWeekNum(time_t /*t*/) const
     {
-        return toRelativeWeekNum(toDayNum(t));
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return toRelativeWeekNum(toDayNum(/*t*/));
     }
 
     /// Number of month from some fixed moment in the past (year * 12 + month)
-    inline unsigned toRelativeMonthNum(DayNum_t d) const
+    inline unsigned toRelativeMonthNum(DayNum_t /*d*/) const
     {
-        return lut[d].year * 12 + lut[d].month;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return lut[d].year * 12 + lut[d].month;
     }
 
-    inline unsigned toRelativeMonthNum(time_t t) const
+    inline unsigned toRelativeMonthNum(time_t /*t*/) const
     {
-        return toRelativeMonthNum(toDayNum(t));
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return toRelativeMonthNum(toDayNum(/*t*/));
     }
 
-    inline unsigned toRelativeQuarterNum(DayNum_t d) const
+    inline unsigned toRelativeQuarterNum(DayNum_t /*d*/) const
     {
-        return lut[d].year * 4 + (lut[d].month - 1) / 3;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return lut[d].year * 4 + (lut[d].month - 1) / 3;
     }
 
-    inline unsigned toRelativeQuarterNum(time_t t) const
+    inline unsigned toRelativeQuarterNum(time_t /*t*/) const
     {
-        return toRelativeQuarterNum(toDayNum(t));
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return toRelativeQuarterNum(toDayNum(/*t*/));
     }
 
     /// We count all hour-length intervals, unrelated to offset changes.
-    inline time_t toRelativeHourNum(time_t t) const
+    inline time_t toRelativeHourNum(time_t /*t*/) const
     {
-        if (offset_is_whole_number_of_hours_everytime)
-            return t / 3600;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //if (offset_is_whole_number_of_hours_everytime)
+        //    return t / 3600;
 
-        /// Assume that if offset was fractional, then the fraction is the same as at the beginning of epoch.
-        /// NOTE This assumption is false for "Pacific/Pitcairn" time zone.
-        return (t + 86400 - offset_at_start_of_epoch) / 3600;
+        ///// Assume that if offset was fractional, then the fraction is the same as at the beginning of epoch.
+        ///// NOTE This assumption is false for "Pacific/Pitcairn" time zone.
+        //return (t + 86400 - offset_at_start_of_epoch) / 3600;
     }
 
-    inline time_t toRelativeHourNum(DayNum_t d) const
+    inline time_t toRelativeHourNum(DayNum_t /*d*/) const
     {
-        return toRelativeHourNum(lut[d].date);
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return toRelativeHourNum(lut[d].date);
     }
 
-    inline time_t toRelativeMinuteNum(time_t t) const
+    inline time_t toRelativeMinuteNum(time_t /*t*/) const
     {
-        return t / 60;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return t / 60;
     }
 
-    inline time_t toRelativeMinuteNum(DayNum_t d) const
+    inline time_t toRelativeMinuteNum(DayNum_t /*d*/) const
     {
-        return toRelativeMinuteNum(lut[d].date);
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return toRelativeMinuteNum(lut[d].date);
     }
 
     /// Create DayNum_t from year, month, day of month.
@@ -377,57 +539,80 @@ public:
         if (unlikely(year < DATE_LUT_MIN_YEAR || year > DATE_LUT_MAX_YEAR || month < 1 || month > 12 || day_of_month < 1 || day_of_month > 31))
             return DayNum_t(0);
 
-        return DayNum_t(years_months_lut[(year - DATE_LUT_MIN_YEAR) * 12 + month - 1] + day_of_month - 1);
+        auto day_num = DateType(year, month, day_of_month).day_count().as_number();
+        return DayNum_t(day_num- start_day_num);
     }
 
-    inline time_t makeDate(UInt16 year, UInt8 month, UInt8 day_of_month) const
+    inline time_t makeDate(UInt16 , UInt8 , UInt8) const
     {
-        return lut[makeDayNum(year, month, day_of_month)].date;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return lut[makeDayNum(year, month, day_of_month)].date;
     }
 
     /** Does not accept daylight saving time as argument: in case of ambiguity, it choose greater timestamp.
       */
-    inline time_t makeDateTime(UInt16 year, UInt8 month, UInt8 day_of_month, UInt8 hour, UInt8 minute, UInt8 second) const
+    inline time_t makeDateTime(UInt16 year, UInt8 month, UInt8 day, UInt8 hour, UInt8 min, UInt8 sec) const
     {
-        size_t index = makeDayNum(year, month, day_of_month);
-        time_t time_offset = hour * 3600 + minute * 60 + second;
-
-        if (time_offset >= lut[index].time_at_offset_change)
-            time_offset -= lut[index].amount_of_offset_change;
-
-        return lut[index].date + time_offset;
+        DateType dt = DateType(year, month, day);
+        DurationType dur = DurationType(hour, min, sec);
+        ltime lt(dt, dur, zone, false);
+        return boost::posix_time::to_time_t(lt.utc_time());
     }
 
-    inline const Values & getValues(DayNum_t d) const { return lut[d]; }
-    inline const Values & getValues(time_t t) const { return lut[findIndex(t)]; }
+    inline Values getValues(DayNum_t d) const { 
+        DateType dt = DateType(DateType::date_rep_type(d + start_day_num));
+        Values v;
+        v.year = dt.year();
+        v.month = dt.month();
+        v.day_of_month = dt.day();
+        return v;
+    }
+    inline Values getValues(time_t t) const { 
+        ptime tm = boost::posix_time::from_time_t(t);
+        ltime lm (tm, zone);
+        DateType dt = lm.local_time().date();
+        Values v;
+        v.year = dt.year();
+        v.month = dt.month();
+        v.day_of_month = dt.day();
+        v.date = t;
+        return v;
+    }
 
-    inline UInt32 toNumYYYYMM(time_t t) const
+    inline UInt32 toNumYYYYMM(time_t /*t*/) const
     {
-        const Values & values = find(t);
-        return values.year * 100 + values.month;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //const Values & values = find(/*t*/);
+        //return values.year * 100 + values.month;
     }
 
     inline UInt32 toNumYYYYMM(DayNum_t d) const
     {
-        const Values & values = lut[d];
-        return values.year * 100 + values.month;
+        DateType dt = DateType(DateType::date_rep_type(d + start_day_num));
+        return dt.year() * 100 + dt.month();
     }
 
-    inline UInt32 toNumYYYYMMDD(time_t t) const
+    inline UInt32 toNumYYYYMMDD(time_t /*t*/) const
     {
-        const Values & values = find(t);
-        return values.year * 10000 + values.month * 100 + values.day_of_month;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //const Values & values = find(/*t*/);
+        //return values.year * 10000 + values.month * 100 + values.day_of_month;
     }
 
     inline UInt32 toNumYYYYMMDD(DayNum_t d) const
     {
-        const Values & values = lut[d];
-        return values.year * 10000 + values.month * 100 + values.day_of_month;
+        DateType dt = DateType(DateType::date_rep_type(d + start_day_num));
+        return dt.year() * 10000 + dt.month() * 100 + dt.day();
     }
 
-    inline time_t YYYYMMDDToDate(UInt32 num) const
+    inline time_t YYYYMMDDToDate(UInt32 ) const
     {
-        return makeDate(num / 10000, num / 100 % 100, num % 100);
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return makeDate(num / 10000, num / 100 % 100, num % 100);
     }
 
     inline DayNum_t YYYYMMDDToDayNum(UInt32 num) const
@@ -436,194 +621,222 @@ public:
     }
 
 
-    inline UInt64 toNumYYYYMMDDhhmmss(time_t t) const
+    inline UInt64 toNumYYYYMMDDhhmmss(time_t /*t*/) const
     {
-        const Values & values = find(t);
-        return
-              toSecond(t)
-            + toMinute(t) * 100
-            + toHour(t) * 10000
-            + UInt64(values.day_of_month) * 1000000
-            + UInt64(values.month) * 100000000
-            + UInt64(values.year) * 10000000000;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //const Values & values = find(/*t*/);
+        //return
+        //      toSecond(/*t*/)
+        //    + toMinute(/*t*/) * 100
+        //    + toHour(/*t*/) * 10000
+        //    + UInt64(values.day_of_month) * 1000000
+        //    + UInt64(values.month) * 100000000
+        //    + UInt64(values.year) * 10000000000;
     }
 
-    inline time_t YYYYMMDDhhmmssToTime(UInt64 num) const
+    inline time_t YYYYMMDDhhmmssToTime(UInt64) const
     {
-        return makeDateTime(
-            num / 10000000000,
-            num / 100000000 % 100,
-            num / 1000000 % 100,
-            num / 10000 % 100,
-            num / 100 % 100,
-            num % 100);
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return makeDateTime(
+        //    num / 10000000000,
+        //    num / 100000000 % 100,
+        //    num / 1000000 % 100,
+        //    num / 10000 % 100,
+        //    num / 100 % 100,
+        //    num % 100);
     }
 
     /// Adding calendar intervals.
     /// Implementation specific behaviour when delta is too big.
 
-    inline time_t addDays(time_t t, Int64 delta) const
+    inline time_t addDays(time_t, Int64 ) const
     {
-        size_t index = findIndex(t);
-        time_t time_offset = toHour(t) * 3600 + toMinute(t) * 60 + toSecond(t);
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //size_t index = findIndex(/*t*/);
+        //time_t time_offset = toHour(/*t*/) * 3600 + toMinute(t) * 60 + toSecond(t);
 
-        index += delta;
+        //index += delta;
 
-        if (time_offset >= lut[index].time_at_offset_change)
-            time_offset -= lut[index].amount_of_offset_change;
+        //if (time_offset >= lut[index].time_at_offset_change)
+        //    time_offset -= lut[index].amount_of_offset_change;
 
-        return lut[index].date + time_offset;
+        //return lut[index].date + time_offset;
     }
 
-    inline time_t addWeeks(time_t t, Int64 delta) const
+    inline time_t addWeeks(time_t, Int64 ) const
     {
-        return addDays(t, delta * 7);
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return addDays(t, delta * 7);
     }
 
-    inline UInt8 saturateDayOfMonth(UInt16 year, UInt8 month, UInt8 day_of_month) const
+    inline UInt8 saturateDayOfMonth(UInt16 /*year*/, UInt8 /*month*/, UInt8 /*day_of_month*/) const
     {
-        if (likely(day_of_month <= 28))
-            return day_of_month;
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //if (likely(day_of_month <= 28))
+        //    return day_of_month;
 
-        UInt8 days_in_month = daysInMonth(year, month);
+        //UInt8 days_in_month = daysInMonth(year, month);
 
-        if (day_of_month > days_in_month)
-            day_of_month = days_in_month;
+        //if (day_of_month > days_in_month)
+        //    day_of_month = days_in_month;
 
-        return day_of_month;
+        //return day_of_month;
     }
 
     /// If resulting month has less deys than source month, then saturation can happen.
     /// Example: 31 Aug + 1 month = 30 Sep.
-    inline time_t addMonths(time_t t, Int64 delta) const
+    inline time_t addMonths(time_t, Int64 ) const
     {
-        DayNum_t result_day = addMonths(toDayNum(t), delta);
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //DayNum_t result_day = addMonths(toDayNum(/*t*/), delta);
 
-        time_t time_offset = toHour(t) * 3600 + toMinute(t) * 60 + toSecond(t);
+        //time_t time_offset = toHour(/*t*/) * 3600 + toMinute(t) * 60 + toSecond(t);
 
-        if (time_offset >= lut[result_day].time_at_offset_change)
-            time_offset -= lut[result_day].amount_of_offset_change;
+        //if (time_offset >= lut[result_day].time_at_offset_change)
+        //    time_offset -= lut[result_day].amount_of_offset_change;
 
-        return lut[result_day].date + time_offset;
+        //return lut[result_day].date + time_offset;
     }
 
-    inline DayNum_t addMonths(DayNum_t d, Int64 delta) const
+    inline DayNum_t addMonths(DayNum_t, Int64) const
     {
-        const Values & values = lut[d];
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //const Values & values = lut[d];
 
-        Int64 month = static_cast<Int64>(values.month) + delta;
+        //Int64 month = static_cast<Int64>(values.month) + delta;
 
-        if (month > 0)
-        {
-            auto year = values.year + (month - 1) / 12;
-            month = ((month - 1) % 12) + 1;
-            auto day_of_month = saturateDayOfMonth(year, month, values.day_of_month);
+        //if (month > 0)
+        //{
+        //    auto year = values.year + (month - 1) / 12;
+        //    month = ((month - 1) % 12) + 1;
+        //    auto day_of_month = saturateDayOfMonth(year, month, values.day_of_month);
 
-            return makeDayNum(year, month, day_of_month);
-        }
-        else
-        {
-            auto year = values.year - (12 - month) / 12;
-            month = 12 - (-month % 12);
-            auto day_of_month = saturateDayOfMonth(year, month, values.day_of_month);
+        //    return makeDayNum(year, month, day_of_month);
+        //}
+        //else
+        //{
+        //    auto year = values.year - (12 - month) / 12;
+        //    month = 12 - (-month % 12);
+        //    auto day_of_month = saturateDayOfMonth(year, month, values.day_of_month);
 
-            return makeDayNum(year, month, day_of_month);
-        }
+        //    return makeDayNum(year, month, day_of_month);
+        //}
     }
 
     /// Saturation can occur if 29 Feb is mapped to non-leap year.
-    inline time_t addYears(time_t t, Int64 delta) const
+    inline time_t addYears(time_t, Int64) const
     {
-        DayNum_t result_day = addYears(toDayNum(t), delta);
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //DayNum_t result_day = addYears(toDayNum(/*t*/), delta);
 
-        time_t time_offset = toHour(t) * 3600 + toMinute(t) * 60 + toSecond(t);
+        //time_t time_offset = toHour(/*t*/) * 3600 + toMinute(t) * 60 + toSecond(t);
 
-        if (time_offset >= lut[result_day].time_at_offset_change)
-            time_offset -= lut[result_day].amount_of_offset_change;
+        //if (time_offset >= lut[result_day].time_at_offset_change)
+        //    time_offset -= lut[result_day].amount_of_offset_change;
 
-        return lut[result_day].date + time_offset;
+        //return lut[result_day].date + time_offset;
     }
 
-    inline DayNum_t addYears(DayNum_t d, Int64 delta) const
+    inline DayNum_t addYears(DayNum_t, Int64) const
     {
-        const Values & values = lut[d];
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //const Values & values = lut[d];
 
-        auto year = values.year + delta;
-        auto month = values.month;
-        auto day_of_month = values.day_of_month;
+        //auto year = values.year + delta;
+        //auto month = values.month;
+        //auto day_of_month = values.day_of_month;
 
-        /// Saturation to 28 Feb can happen.
-        if (unlikely(day_of_month == 29 && month == 2))
-            day_of_month = saturateDayOfMonth(year, month, day_of_month);
+        ///// Saturation to 28 Feb can happen.
+        //if (unlikely(day_of_month == 29 && month == 2))
+        //    day_of_month = saturateDayOfMonth(year, month, day_of_month);
 
-        return makeDayNum(year, month, day_of_month);
+        //return makeDayNum(year, month, day_of_month);
     }
 
 
-    inline std::string timeToString(time_t t) const
+    inline std::string timeToString(time_t /*t*/) const
     {
-        const Values & values = find(t);
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //const Values & values = find(/*t*/);
 
-        std::string s {"0000-00-00 00:00:00"};
+        //std::string s {"0000-00-00 00:00:00"};
 
-        s[0] += values.year / 1000;
-        s[1] += (values.year / 100) % 10;
-        s[2] += (values.year / 10) % 10;
-        s[3] += values.year % 10;
-        s[5] += values.month / 10;
-        s[6] += values.month % 10;
-        s[8] += values.day_of_month / 10;
-        s[9] += values.day_of_month % 10;
+        //s[0] += values.year / 1000;
+        //s[1] += (values.year / 100) % 10;
+        //s[2] += (values.year / 10) % 10;
+        //s[3] += values.year % 10;
+        //s[5] += values.month / 10;
+        //s[6] += values.month % 10;
+        //s[8] += values.day_of_month / 10;
+        //s[9] += values.day_of_month % 10;
 
-        auto hour = toHour(t);
-        auto minute = toMinute(t);
-        auto second = toSecond(t);
+        //auto hour = toHour(/*t*/);
+        //auto minute = toMinute(/*t*/);
+        //auto second = toSecond(/*t*/);
 
-        s[11] += hour / 10;
-        s[12] += hour % 10;
-        s[14] += minute / 10;
-        s[15] += minute % 10;
-        s[17] += second / 10;
-        s[18] += second % 10;
+        //s[11] += hour / 10;
+        //s[12] += hour % 10;
+        //s[14] += minute / 10;
+        //s[15] += minute % 10;
+        //s[17] += second / 10;
+        //s[18] += second % 10;
 
-        return s;
+        //return s;
     }
 
-    inline std::string dateToString(time_t t) const
+    inline std::string dateToString(time_t /*t*/) const
     {
-        const Values & values = find(t);
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //const Values & values = find(/*t*/);
 
-        std::string s {"0000-00-00"};
+        //std::string s {"0000-00-00"};
 
-        s[0] += values.year / 1000;
-        s[1] += (values.year / 100) % 10;
-        s[2] += (values.year / 10) % 10;
-        s[3] += values.year % 10;
-        s[5] += values.month / 10;
-        s[6] += values.month % 10;
-        s[8] += values.day_of_month / 10;
-        s[9] += values.day_of_month % 10;
+        //s[0] += values.year / 1000;
+        //s[1] += (values.year / 100) % 10;
+        //s[2] += (values.year / 10) % 10;
+        //s[3] += values.year % 10;
+        //s[5] += values.month / 10;
+        //s[6] += values.month % 10;
+        //s[8] += values.day_of_month / 10;
+        //s[9] += values.day_of_month % 10;
 
-        return s;
+        //return s;
     }
 
-    inline std::string dateToString(DayNum_t d) const
+    inline std::string dateToString(DayNum_t /*d*/) const
     {
-        const Values & values = lut[d];
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //const Values & values = lut[d];
 
-        std::string s {"0000-00-00"};
+        //std::string s {"0000-00-00"};
 
-        s[0] += values.year / 1000;
-        s[1] += (values.year / 100) % 10;
-        s[2] += (values.year / 10) % 10;
-        s[3] += values.year % 10;
-        s[5] += values.month / 10;
-        s[6] += values.month % 10;
-        s[8] += values.day_of_month / 10;
-        s[9] += values.day_of_month % 10;
+        //s[0] += values.year / 1000;
+        //s[1] += (values.year / 100) % 10;
+        //s[2] += (values.year / 10) % 10;
+        //s[3] += values.year % 10;
+        //s[5] += values.month / 10;
+        //s[6] += values.month % 10;
+        //s[8] += values.day_of_month / 10;
+        //s[9] += values.day_of_month % 10;
 
-        return s;
+        //return s;
     }
 
-    inline bool isOffsetWholeNumberOfHoursEveryTime() const { return offset_is_whole_number_of_hours_everytime; }
+    inline bool isOffsetWholeNumberOfHoursEveryTime() const { 
+          std::cout<<__LINE__<<std::endl;
+        throw Exception("Not Implement yet");
+        //return offset_is_whole_number_of_hours_everytime; 
+    }
 };
