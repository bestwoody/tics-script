diff --git a/libs/libcommon/include/common/DateLUTImpl.h b/libs/libcommon/include/common/DateLUTImpl.h
index 535c863eeb3e..8ad8c29a050f 100644
--- a/libs/libcommon/include/common/DateLUTImpl.h
+++ b/libs/libcommon/include/common/DateLUTImpl.h
@@ -6,16 +6,17 @@
 
 #include <ctime>
 
-#define DATE_LUT_MAX (0xFFFFFFFFU - 86400)
-#define DATE_LUT_MAX_DAY_NUM (0xFFFFFFFFU / 86400)
+#define DATE_LUT_MAX (0xFFFFFFFFFFFFFFFLL - 86400)
+#define DATE_LUT_MIN -30610224000LL
+#define DATE_LUT_MAX_DAY_NUM 36500000
 /// Table size is bigger than DATE_LUT_MAX_DAY_NUM to fill all indices within UInt16 range: this allows to remove extra check.
-#define DATE_LUT_SIZE 0x10000
-#define DATE_LUT_MIN_YEAR 1970
-#define DATE_LUT_MAX_YEAR 2105 /// Last supported year
+#define DATE_LUT_SIZE 36652424
+#define DATE_LUT_MIN_YEAR 1000 
+#define DATE_LUT_MAX_YEAR 9999 /// Last supported year
 #define DATE_LUT_YEARS (1 + DATE_LUT_MAX_YEAR - DATE_LUT_MIN_YEAR) /// Number of years in lookup table
 
 
-STRONG_TYPEDEF(UInt16, DayNum_t);
+STRONG_TYPEDEF(UInt32, DayNum_t);
 
 
 /** Lookup table to conversion of time to date, and to month / year / day of week / day of month and so on.
@@ -32,7 +33,7 @@ public:
         /// Least significat 32 bits from time_t at beginning of the day.
         /// If the unix timestamp of beginning of the day is negative (example: 1970-01-01 MSK, where time_t == -10800), then value is zero.
         /// Change to time_t; change constants above; and recompile the sources if you need to support time after 2105 year.
-        UInt32 date;
+        time_t date;
 
         /// Properties of the day.
         UInt16 year;
@@ -74,7 +75,7 @@ private:
     inline size_t findIndex(time_t t) const
     {
         /// First guess.
-        size_t guess = t / 86400;
+        size_t guess = (t - DATE_LUT_MIN) / 86400;
         if (guess >= DATE_LUT_MAX_DAY_NUM)
             return 0;
         if (t >= lut[guess].date && t < lut[guess + 1].date)
@@ -236,7 +237,7 @@ public:
         if (res >= lut[index].time_at_offset_change)
             res += lut[index].amount_of_offset_change;
 
-        return res - offset_at_start_of_epoch; /// Starting at 1970-01-01 00:00:00 local time.
+        return res - offset_at_start_of_epoch; /// Starting at 1000-01-01 00:00:00 local time.
     }
 
     inline unsigned toHour(time_t t) const
@@ -267,7 +268,21 @@ public:
       *  each minute, with added or subtracted leap second, spans exactly 60 unix timestamps.
       */
 
-    inline unsigned toSecond(time_t t) const { return t % 60; }
+    inline unsigned toSecond(time_t t) const 
+    {
+        size_t index = findIndex(t);
+
+        /// If it is not 1970 year (findIndex found nothing appropriate),
+        ///  than limit number of hours to avoid insane results like 1970-01-01 89:28:15
+        if (unlikely(index == 0))
+            return static_cast<unsigned>((t + offset_at_start_of_epoch) / 3600) % 24;
+
+        time_t res = t - lut[index].date;
+
+        if (res >= lut[index].time_at_offset_change)
+            res += lut[index].amount_of_offset_change;
+        return (res % 60 + 60) % 60; 
+    }
 
     inline unsigned toMinute(time_t t) const
     {
