diff --git a/dbms/src/Storages/StorageMergeTree.cpp b/dbms/src/Storages/StorageMergeTree.cpp
index da205e9a2930..08fe7c676d4e 100644
--- a/dbms/src/Storages/StorageMergeTree.cpp
+++ b/dbms/src/Storages/StorageMergeTree.cpp
@@ -14,6 +14,16 @@
 #include <Storages/MergeTree/MergeTreeData.h>
 #include <Storages/MergeTree/ActiveDataPartSet.h>
 
+#include <Storages/MutableSupport.h>
+#include <Parsers/ASTInsertQuery.h>
+#include <Parsers/ASTDeleteQuery.h>
+#include <Parsers/ASTSelectQuery.h>
+
+#include <DataStreams/RemoveColumnsBlockInputStream.h>
+#include <DataStreams/AdditionalColumnsBlockOutputStream.h>
+#include <DataStreams/DedupSortedBlockInputStream.h>
+#include <DataStreams/InBlockDedupBlockOutputStream.h>
+
 #include <Poco/DirectoryIterator.h>
 #include <Poco/File.h>
 
@@ -105,12 +115,93 @@ BlockInputStreams StorageMergeTree::read(
     const size_t max_block_size,
     const unsigned num_streams)
 {
-    return reader.read(column_names, query_info, context, processed_stage, max_block_size, num_streams, 0);
+    auto res = reader.read(column_names, query_info, context, processed_stage, max_block_size, num_streams, 0);
+    const ASTSelectQuery * select_query = typeid_cast<const ASTSelectQuery *>(query_info.query.get());
+
+    if (data.merging_params.mode == MergeTreeData::MergingParams::Mutable)
+    {
+        if (select_query && !select_query->raw_for_mutable)
+        {
+            LOG_DEBUG(log, "Mutable table dedup read.");
+            Names filtered_names;
+            filtered_names.push_back(MutableSupport::version_column_name);
+            filtered_names.push_back(MutableSupport::delmark_column_name);
+            BlockInputStreams filtered(res.size());
+            for (size_t i = 0; i < res.size(); ++i)
+                filtered[i] = std::make_shared<RemoveColumnsBlockInputStream>(res[i], filtered_names);
+            res = filtered;
+        }
+        else
+            LOG_DEBUG(log, "Mutable table raw read.");
+    }
+    else if (select_query && select_query->raw_for_mutable)
+    {
+        throw Exception("Only " + MutableSupport::storage_name + " support SELRAW.", ErrorCodes::BAD_ARGUMENTS);
+    }
+    return res;
 }
 
-BlockOutputStreamPtr StorageMergeTree::write(const ASTPtr & /*query*/, const Settings & /*settings*/)
+UInt64 StorageMergeTree::getVersionSeed(const Settings & /* settings */) const
 {
-    return std::make_shared<MergeTreeBlockOutputStream>(*this);
+    // NOTE:
+    // We don't guarantee thread safe.
+    // In that case, we assume data not related in diffent thread.
+    // So we can use the same version number.
+    //
+    // WARNING: NOT safe in distribed mode.
+
+    // TODO:
+    // It's faster if we use (increment.value << 32).
+    // We use '* 1000000' for readable results, just for now
+    return (increment.value + 1) * 1000000;
+}
+
+BlockOutputStreamPtr StorageMergeTree::write(const ASTPtr & query, const Settings & settings)
+{
+    BlockOutputStreamPtr res = std::make_shared<MergeTreeBlockOutputStream>(*this);
+
+    const ASTInsertQuery * insert_query = typeid_cast<const ASTInsertQuery *>(&*query);
+    const ASTDeleteQuery * delete_query = typeid_cast<const ASTDeleteQuery *>(&*query);
+
+    if (data.merging_params.mode == MergeTreeData::MergingParams::Mutable)
+    {
+        if (insert_query)
+        {
+            if (!insert_query->is_import)
+            {
+                LOG_DEBUG(log, "Mutable table writing, add version column and del-mark column.");
+                AdditionalBlockGenerators gens
+                {
+                    std::make_shared<AdditionalBlockGeneratorIncrease<UInt64>>(MutableSupport::version_column_name,
+                        getVersionSeed(settings)),
+                    std::make_shared<AdditionalBlockGeneratorConst<UInt8>>(MutableSupport::delmark_column_name, 0)
+                };
+                res = std::make_shared<AdditionalColumnsBlockOutputStream>(res, gens);
+                // TODO: Dedup in MergeTreeDataWriter may be better, in case some one glue some blocks together
+                res = std::make_shared<InBlockDedupBlockOutputStream>(res, data.getSortDescription());
+            }
+            else
+                LOG_DEBUG(log, "Mutable table importing.");
+        }
+        else if (delete_query)
+        {
+            LOG_DEBUG(log, "Mutable table deleting.");
+            AdditionalBlockGenerators gens
+            {
+                std::make_shared<AdditionalBlockGeneratorConst<UInt64>>(MutableSupport::version_column_name,
+                    getVersionSeed(settings)),
+                std::make_shared<AdditionalBlockGeneratorConst<UInt8>>(MutableSupport::delmark_column_name, 1)
+            };
+            res = std::make_shared<AdditionalColumnsBlockOutputStream>(res, gens);
+            res = std::make_shared<InBlockDedupBlockOutputStream>(res, data.getSortDescription());
+        }
+    }
+    else if ((insert_query && insert_query->is_import) || delete_query)
+    {
+        throw Exception("Only " + MutableSupport::storage_name + " support IMPORT or DELETE.", ErrorCodes::BAD_ARGUMENTS);
+    }
+
+    return res;
 }
 
 bool StorageMergeTree::checkTableCanBeDropped() const
@@ -120,6 +211,11 @@ bool StorageMergeTree::checkTableCanBeDropped() const
     return true;
 }
 
+const OrderedNameSet & StorageMergeTree::getHiddenColumnsImpl() const
+{
+    return MutableSupport::instance().hiddenColumns(getName());
+}
+
 void StorageMergeTree::drop()
 {
     shutdown();
@@ -490,6 +586,18 @@ void StorageMergeTree::dropPartition(const ASTPtr & /*query*/, const ASTPtr & pa
     LOG_INFO(log, (detach ? "Detached " : "Removed ") << removed_parts << " parts inside partition ID " << partition_id << ".");
 }
 
+void StorageMergeTree::truncate(const ASTPtr & /*query*/, const Context & /*context*/)
+{
+    auto lock = lockForAlter(__PRETTY_FUNCTION__);
+    
+    MergeTreeData::DataParts parts = data.getDataParts();
+
+    for (const auto & part : parts)
+    {
+        LOG_DEBUG(log, "Removing part " << part->name);
+        data.removePartsFromWorkingSet({part}, true);
+    }
+}
 
 void StorageMergeTree::attachPartition(const ASTPtr & partition, bool part, const Context & context)
 {
