diff --git a/dbms/src/Storages/MergeTree/MergeTreeData.cpp b/dbms/src/Storages/MergeTree/MergeTreeData.cpp
index a66fc19016b1..edb275233d66 100644
--- a/dbms/src/Storages/MergeTree/MergeTreeData.cpp
+++ b/dbms/src/Storages/MergeTree/MergeTreeData.cpp
@@ -306,8 +306,8 @@ void MergeTreeData::MergingParams::check(const NamesAndTypesList & columns) cons
         throw Exception("Sign column for MergeTree cannot be specified in modes except Collapsing or VersionedCollapsing.",
                         ErrorCodes::LOGICAL_ERROR);
 
-    if (!version_column.empty() && mode != MergingParams::Replacing && mode != MergingParams::VersionedCollapsing)
-        throw Exception("Version column for MergeTree cannot be specified in modes except Replacing or VersionedCollapsing.",
+    if (!version_column.empty() && mode != MergingParams::Replacing && mode != MergingParams::VersionedCollapsing && mode != MergingParams::Mutable)
+        throw Exception("Version column for MergeTree cannot be specified in modes except Replacing or VersionedCollapsing or Mutable.",
                         ErrorCodes::LOGICAL_ERROR);
 
     if (!columns_to_sum.empty() && mode != MergingParams::Summing)
@@ -410,6 +410,7 @@ String MergeTreeData::MergingParams::getModeName() const
         case Summing:       return "Summing";
         case Aggregating:   return "Aggregating";
         case Replacing:     return "Replacing";
+        case Mutable:       return "Mutable";
         case Graphite:      return "Graphite";
         case VersionedCollapsing:  return "VersionedCollapsing";
 
@@ -1211,7 +1212,7 @@ MergeTreeData::AlterDataPartTransactionPtr MergeTreeData::alterDataPart(
         MarkRanges ranges{MarkRange(0, part->marks_count)};
         BlockInputStreamPtr part_in = std::make_shared<MergeTreeBlockInputStream>(
             *this, part, DEFAULT_MERGE_BLOCK_SIZE, 0, 0, expression->getRequiredColumns(), ranges,
-            false, nullptr, "", false, 0, DBMS_DEFAULT_BUFFER_SIZE, false);
+            false, nullptr, "", false, 0, DBMS_DEFAULT_BUFFER_SIZE, false, false);
 
         auto compression_settings = this->context.chooseCompressionSettings(
             part->bytes_on_disk,
@@ -2031,6 +2032,44 @@ String MergeTreeData::getPartitionIDFromQuery(const ASTPtr & ast, const Context
     return partition_id;
 }
 
+NameSet MergeTreeData::getPartitionIDsInLiteral(const ASTPtr &ast, const Context &)
+{
+    const auto & partition_ast = typeid_cast<const ASTPartition &>(*ast);
+
+    if (!partition_ast.value)
+        return {partition_ast.id};
+
+    const auto * partition_lit = typeid_cast<const ASTLiteral *>(partition_ast.value.get());
+    if (partition_lit && partition_lit->value.getType() == Field::Types::String)
+    {
+        return {partition_lit->value.get<String>()};
+    }
+
+    const auto * partition_function = typeid_cast<const ASTFunction *>(partition_ast.value.get());
+    if (partition_function && partition_function->name == "tuple")
+    {
+        NameSet ids;
+        bool ok = true;
+        for (const auto & item : partition_function->arguments->children)
+        {
+            const auto * partition_lit = typeid_cast<const ASTLiteral *>(item.get());
+            if (partition_lit && partition_lit->value.getType() == Field::Types::String)
+            {
+                ids.emplace(partition_lit->value.get<String>());
+            }
+            else
+            {
+                ok = false;
+                break;
+            }
+        }
+        if (ok)
+            return ids;
+    }
+
+    throw Exception("Unable to parse partition values in literal form: `" + partition_ast.fields_str.toString() + "`");
+}
+
 MergeTreeData::DataPartsVector MergeTreeData::getDataPartsVector(const DataPartStates & affordable_states, DataPartStateVector * out_states) const
 {
     DataPartsVector res;
