diff --git a/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
index 333f9c7cc602..8320d0170fbf 100644
--- a/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
+++ b/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
@@ -1,16 +1,6 @@
 #include <boost/rational.hpp>   /// For calculations related to sampling coefficients.
 #include <optional>
 
-#include <Common/FieldVisitors.h>
-#include <Storages/MergeTree/MergeTreeDataSelectExecutor.h>
-#include <Storages/MergeTree/MergeTreeBlockInputStream.h>
-#include <Storages/MergeTree/MergeTreeReadPool.h>
-#include <Storages/MergeTree/MergeTreeThreadBlockInputStream.h>
-#include <Storages/MergeTree/KeyCondition.h>
-#include <Parsers/ASTIdentifier.h>
-#include <Parsers/ASTFunction.h>
-#include <Parsers/ASTSampleRatio.h>
-
 /// Allow to use __uint128_t as a template parameter for boost::rational.
 // https://stackoverflow.com/questions/41198673/uint128-t-not-working-with-clang-and-libstdc
 #if !defined(__GLIBCXX_BITSIZE_INT_N_0) && defined(__SIZEOF_INT128__)
@@ -25,10 +15,28 @@ namespace std
         static constexpr int radix = 2;
         static constexpr int digits = 128;
         static constexpr __uint128_t min () { return 0; } // used in boost 1.65.1+
+        static constexpr __uint128_t max () { return __uint128_t(-1); } // used in boost 1.65.1+
     };
 }
 #endif
 
+#include <Common/FieldVisitors.h>
+#include <Common/getNumberOfPhysicalCPUCores.h>
+#include <Storages/MergeTree/MergeTreeDataSelectExecutor.h>
+#include <Storages/MergeTree/MergeTreeBlockInputStream.h>
+#include <Storages/MergeTree/MergeTreeReadPool.h>
+#include <Storages/MergeTree/MergeTreeThreadBlockInputStream.h>
+#include <Storages/MergeTree/KeyCondition.h>
+#include <Parsers/ASTIdentifier.h>
+#include <Parsers/ASTFunction.h>
+#include <Parsers/ASTSampleRatio.h>
+
+#include <Storages/MutableSupport.h>
+#include <DataStreams/DebugPrintBlockInputStream.h>
+#include <DataStreams/DedupSortedBlockInputStream.h>
+#include <DataStreams/ReplacingDeletingSortedBlockInputStream.h>
+#include <DataStreams/AsynchronousBlockInputStream.h>
+
 #include <DataStreams/ExpressionBlockInputStream.h>
 #include <DataStreams/FilterBlockInputStream.h>
 #include <DataStreams/CollapsingFinalBlockInputStream.h>
@@ -39,12 +47,12 @@ namespace std
 #include <DataStreams/ReplacingSortedBlockInputStream.h>
 #include <DataStreams/AggregatingSortedBlockInputStream.h>
 #include <DataStreams/VersionedCollapsingSortedBlockInputStream.h>
+#include <DataStreams/ConcatBlockInputStream.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeEnum.h>
 #include <Storages/VirtualColumnUtils.h>
 
-
 namespace ProfileEvents
 {
     extern const Event SelectedParts;
@@ -140,7 +148,6 @@ BlockInputStreams MergeTreeDataSelectExecutor::read(
     Int64 max_block_number_to_read) const
 {
     size_t part_index = 0;
-
     MergeTreeData::DataPartsVector parts = data.getDataPartsVector();
 
     /// If query contains restrictions on the virtual column `_part` or `_part_index`, select only parts suitable for it.
@@ -512,6 +519,15 @@ BlockInputStreams MergeTreeDataSelectExecutor::read(
                 SizeLimits(settings.max_rows_to_transfer, settings.max_bytes_to_transfer, settings.transfer_overflow_mode)).read();
     }
 
+    /// @todo Make sure partition select works properly when sampling is used!
+
+    NameSet valid_partitions;
+    if (const auto * select = typeid_cast<const ASTSelectQuery *>(query_info.query.get()))
+    {
+        if (select->partition_expression_list)
+            valid_partitions = data.getPartitionIDsInLiteral(select->partition_expression_list, context);
+    }
+
     RangesInDataParts parts_with_ranges;
 
     /// Let's find what range to read from each part.
@@ -526,7 +542,9 @@ BlockInputStreams MergeTreeDataSelectExecutor::read(
         else
             ranges.ranges = MarkRanges{MarkRange{0, part->marks_count}};
 
-        if (!ranges.ranges.empty())
+        /// Make sure this part is in mark range and contained by valid partitions.
+        if (!ranges.ranges.empty()
+            && (valid_partitions.empty() || valid_partitions.find(part->partition.getID(data)) != valid_partitions.end()))
         {
             parts_with_ranges.push_back(ranges);
 
@@ -546,9 +564,35 @@ BlockInputStreams MergeTreeDataSelectExecutor::read(
     ProfileEvents::increment(ProfileEvents::SelectedRanges, sum_ranges);
     ProfileEvents::increment(ProfileEvents::SelectedMarks, sum_marks);
 
+    bool is_mutable_engine = (data.merging_params.mode == MergeTreeData::MergingParams::Mutable && !select.raw_for_mutable);
+
     BlockInputStreams res;
+    if (is_mutable_engine)
+    {
+        column_names_to_read.insert(column_names_to_read.end(), MutableSupport::version_column_name);
+        column_names_to_read.insert(column_names_to_read.end(), MutableSupport::delmark_column_name);
 
-    if (select.final())
+        std::vector<String> add_columns = data.getPrimaryExpression()->getRequiredColumns();
+        column_names_to_read.insert(column_names_to_read.end(), add_columns.begin(), add_columns.end());
+
+        std::sort(column_names_to_read.begin(), column_names_to_read.end());
+        column_names_to_read.erase(std::unique(column_names_to_read.begin(), column_names_to_read.end()), column_names_to_read.end());
+
+        res = spreadMarkRangesAmongStreamsOnMutableEngine(
+            parts_with_ranges,
+            column_names_to_read,
+            max_block_size,
+            num_streams,
+            settings.use_uncompressed_cache,
+            prewhere_actions,
+            prewhere_column,
+            virt_column_names,
+            settings);
+
+        if (res.size() == 0)
+            return res;
+    }
+    else if (select.final())
     {
         /// Add columns needed to calculate primary key and the sign.
         std::vector<String> add_columns = data.getPrimaryExpression()->getRequiredColumns();
@@ -814,6 +858,9 @@ BlockInputStreams MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsFinal
 
         case MergeTreeData::MergingParams::Graphite:
             throw Exception("GraphiteMergeTree doesn't support FINAL", ErrorCodes::LOGICAL_ERROR);
+
+        case MergeTreeData::MergingParams::Mutable:
+            throw Exception("MutableMergeTree doesn't handle here", ErrorCodes::LOGICAL_ERROR);
     }
 
     return {merged};
@@ -926,4 +973,182 @@ MarkRanges MergeTreeDataSelectExecutor::markRangesFromPKRange(
     return res;
 }
 
+
+BlockInputStreams MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsOnMutableEngine(
+    const RangesInDataParts & parts_with_ranges,
+    const Names & column_names,
+    size_t max_block_size,
+    unsigned num_streams,
+    bool use_uncompressed_cache,
+    ExpressionActionsPtr prewhere_actions,
+    const String & prewhere_column,
+    const Names & virt_columns,
+    const Settings & settings) const
+{
+    LOG_DEBUG(log, "Number of streams: " << num_streams);
+
+    size_t sum_marks = 0;
+
+    const size_t max_marks_to_use_cache =
+        (settings.merge_tree_max_rows_to_use_cache + data.index_granularity - 1) / data.index_granularity;
+    if (sum_marks > max_marks_to_use_cache)
+        use_uncompressed_cache = false;
+
+    std::unordered_map<std::string, RangesInDataParts> partitions;
+    for (size_t part_index = 0; part_index < parts_with_ranges.size(); ++part_index)
+    {
+        const RangesInDataPart & part = parts_with_ranges[part_index];
+        auto partition_id = part.data_part->partition.getID(data);
+        if (partitions.find(partition_id) == partitions.end())
+            partitions[partition_id] = RangesInDataParts();
+        partitions[partition_id].emplace_back(part);
+    }
+
+    // TODO: Use one stream if data is small enough
+
+    BlockInputStreams res;
+
+    MutableSupport::DeduperType type = MutableSupport::toDeduperType(settings.mutable_deduper);
+
+    if (type == MutableSupport::DeduperOriginStreams)
+    {
+        for (auto it = parts_with_ranges.begin(); it != parts_with_ranges.end(); ++it)
+        {
+            const RangesInDataPart & part = *it;
+            BlockInputStreamPtr source_stream = std::make_shared<MergeTreeBlockInputStream>(
+                data, part.data_part, max_block_size, settings.preferred_block_size_bytes,
+                settings.preferred_max_column_in_block_size_bytes, column_names, part.ranges, use_uncompressed_cache,
+                prewhere_actions, prewhere_column, true, settings.min_bytes_to_use_direct_io, settings.max_read_buffer_size, true,
+                virt_columns, part.part_index_in_query);
+            // source_stream = std::make_shared<DebugPrintBlockInputStream>(source_stream);
+            source_stream = std::make_shared<ExpressionBlockInputStream>(source_stream, data.getPrimaryExpression());
+            res.emplace_back(source_stream);
+        }
+    }
+    else if (type == MutableSupport::DeduperOriginUnity)
+    {
+        BlockInputStreams merging;
+        for (auto it = parts_with_ranges.begin(); it != parts_with_ranges.end(); ++it)
+        {
+            const RangesInDataPart & part = *it;
+            BlockInputStreamPtr source_stream = std::make_shared<MergeTreeBlockInputStream>(
+                data, part.data_part, max_block_size, settings.preferred_block_size_bytes,
+                settings.preferred_max_column_in_block_size_bytes, column_names, part.ranges, use_uncompressed_cache,
+                prewhere_actions, prewhere_column, true, settings.min_bytes_to_use_direct_io, settings.max_read_buffer_size, true,
+                virt_columns, part.part_index_in_query);
+            // source_stream = std::make_shared<DebugPrintBlockInputStream>(source_stream);
+            source_stream = std::make_shared<ExpressionBlockInputStream>(source_stream, data.getPrimaryExpression());
+            merging.emplace_back(source_stream);
+        }
+        res.emplace_back(std::make_shared<ReplacingDeletingSortedBlockInputStream>(merging, data.getSortDescription(),
+            MutableSupport::version_column_name, MutableSupport::delmark_column_name, DEFAULT_MERGE_BLOCK_SIZE, nullptr, false, true));
+    }
+    else if (type == MutableSupport::DeduperReplacingUnity)
+    {
+        BlockInputStreams merging;
+        for (auto it = partitions.begin(); it != partitions.end(); ++it)
+        {
+            RangesInDataParts & parts = it->second;
+
+            for (size_t i = 0; i < parts.size(); ++i)
+            {
+                const RangesInDataPart & part = parts[i];
+                BlockInputStreamPtr source_stream = std::make_shared<MergeTreeBlockInputStream>(
+                    data, part.data_part, max_block_size, settings.preferred_block_size_bytes,
+                    settings.preferred_max_column_in_block_size_bytes, column_names, part.ranges, use_uncompressed_cache,
+                    prewhere_actions, prewhere_column, true, settings.min_bytes_to_use_direct_io, settings.max_read_buffer_size, true,
+                    virt_columns, part.part_index_in_query);
+                // source_stream = std::make_shared<DebugPrintBlockInputStream>(source_stream);
+                source_stream = std::make_shared<ExpressionBlockInputStream>(source_stream, data.getPrimaryExpression());
+                merging.emplace_back(source_stream);
+            }
+        }
+        res.emplace_back(std::make_shared<ReplacingDeletingSortedBlockInputStream>(merging, data.getSortDescription(),
+            MutableSupport::version_column_name, MutableSupport::delmark_column_name, DEFAULT_MERGE_BLOCK_SIZE, nullptr, false, true));
+    }
+    else if (type == MutableSupport::DeduperReplacingPartitioning || type == MutableSupport::DeduperReplacingPartitioningOpt)
+    {
+        BlockInputStreams partitionStreams;
+        for (auto it = partitions.begin(); it != partitions.end(); ++it)
+        {
+            RangesInDataParts & parts = it->second;
+            BlockInputStreams merging;
+
+            for (size_t i = 0; i < parts.size(); ++i)
+            {
+                const RangesInDataPart & part = parts[i];
+
+                BlockInputStreamPtr source_stream = std::make_shared<MergeTreeBlockInputStream>(
+                    data, part.data_part, max_block_size, settings.preferred_block_size_bytes,
+                    settings.preferred_max_column_in_block_size_bytes, column_names, part.ranges, use_uncompressed_cache,
+                    prewhere_actions, prewhere_column, true, settings.min_bytes_to_use_direct_io, settings.max_read_buffer_size, true,
+                    virt_columns, part.part_index_in_query);
+                // source_stream = std::make_shared<DebugPrintBlockInputStream>(source_stream,
+                //     "partition-" + part.data_part->partition.getID(data) + ".part-" + part.data_part->name);
+                source_stream = std::make_shared<ExpressionBlockInputStream>(source_stream, data.getPrimaryExpression());
+                // source_stream = std::make_shared<AsynchronousBlockInputStream>(source_stream);
+                merging.emplace_back(source_stream);
+            }
+
+            // TODO: Optimization: if (merging.size() == 1)
+            BlockInputStreamPtr merged = std::make_shared<ReplacingDeletingSortedBlockInputStream>(merging, data.getSortDescription(),
+                MutableSupport::version_column_name, MutableSupport::delmark_column_name, DEFAULT_MERGE_BLOCK_SIZE, nullptr, false, true,
+                type == MutableSupport::DeduperReplacingPartitioningOpt);
+
+            // merged = std::make_shared<DebugPrintBlockInputStream>(merged, "partition-" + parts[0].data_part->partition.getID(data));
+            // merged = std::make_shared<AsynchronousBlockInputStream>(merged);
+            partitionStreams.emplace_back(merged);
+        }
+
+        size_t streams = partitionStreams.size();
+        size_t cpu = getNumberOfPhysicalCPUCores();
+        if (streams <= cpu)
+        {
+            res = partitionStreams;
+        }
+        else
+        {
+            size_t n = streams / cpu;
+            size_t r = streams % cpu;
+            size_t offset = 0;
+            for (size_t i = 0; i < cpu; i ++)
+            {
+                int count = (r != 0 && i <= (r - 1)) ? n + 1 : n;
+                BlockInputStreams sub(partitionStreams.begin() + offset, partitionStreams.begin() + offset + count);
+                res.emplace_back(std::make_shared<ConcatBlockInputStream>(sub));
+                offset += count;
+            }
+        }
+    }
+    else if (type == MutableSupport::DeduperDedupPartitioning)
+    {
+        for (auto it = partitions.begin(); it != partitions.end(); ++it)
+        {
+            RangesInDataParts & parts = it->second;
+            BlockInputStreams merging;
+
+            for (size_t i = 0; i < parts.size(); ++i)
+            {
+                const RangesInDataPart & part = parts[i];
+
+                BlockInputStreamPtr source_stream = std::make_shared<MergeTreeBlockInputStream>(
+                    data, part.data_part, max_block_size, settings.preferred_block_size_bytes,
+                    settings.preferred_max_column_in_block_size_bytes, column_names, part.ranges, use_uncompressed_cache,
+                    prewhere_actions, prewhere_column, true, settings.min_bytes_to_use_direct_io, settings.max_read_buffer_size, true,
+                    virt_columns, part.part_index_in_query);
+                // source_stream = std::make_shared<DebugPrintBlockInputStream>(source_stream,
+                //     "partition-" + part.data_part->partition.getID(data) + ".part-" + part.data_part->name);
+                source_stream = std::make_shared<ExpressionBlockInputStream>(source_stream, data.getPrimaryExpression());
+                merging.emplace_back(source_stream);
+            }
+
+            BlockInputStreamPtr merged = std::make_shared<DedupSortedBlockInputStream>(merging, data.getSortDescription());
+            // merged = std::make_shared<DebugPrintBlockInputStream>(merged, "partition-" + parts[0].data_part->partition.getID(data));
+            res.emplace_back(merged);
+        }
+    }
+
+    return res;
+}
+
 }
