diff --git a/dbms/src/Server/TCPHandler.cpp b/dbms/src/Server/TCPHandler.cpp
index 53ca6c8699f8..1ee4923ac34c 100644
--- a/dbms/src/Server/TCPHandler.cpp
+++ b/dbms/src/Server/TCPHandler.cpp
@@ -5,6 +5,7 @@
 #include <Common/ClickHouseRevision.h>
 
 #include <Common/Stopwatch.h>
+#include <Common/ProfileEvents.h>
 
 #include <IO/Progress.h>
 
@@ -33,6 +34,21 @@
 #include <Common/NetException.h>
 #include <ext/scope_guard.h>
 
+#include <Interpreters/SharedQueries.h>
+
+
+namespace ProfileEvents
+{
+    extern const Event PersistedMarksFileHits;
+    extern const Event PersistedMarksFileMisses;
+    extern const Event PersistedMarksFileBusy;
+    extern const Event PersistedMarksFileUpdate;
+    extern const Event PersistedCacheHits;
+    extern const Event PersistedCacheMisses;
+    extern const Event PersistedCacheBusy;
+    extern const Event PersistedCacheUpdate;
+}
+
 
 namespace DB
 {
@@ -136,6 +152,8 @@ void TCPHandler::runImpl()
         std::unique_ptr<Exception> exception;
         bool network_error = false;
 
+        String shared_query_id;
+
         try
         {
             /// Restore context of request.
@@ -159,7 +177,29 @@ void TCPHandler::runImpl()
             state.maybe_compressed_in.reset();  /// For more accurate accounting by MemoryTracker.
 
             /// Processing Query
-            state.io = executeQuery(state.query, query_context, false, state.stage);
+            const Settings & settings = query_context.getSettingsRef();
+            if (settings.shared_query_clients && !state.query_id.empty())
+            {
+                LOG_DEBUG(log, "shared query");
+
+                state.io = query_context.getSharedQueries()->getOrCreateBlockIO(
+                    state.query_id,
+                    settings.shared_query_clients,
+                    [&]()
+                    {
+                        return executeQuery(state.query, query_context, false, state.stage);
+                    });
+
+                /// As getOrCreateBlockIO could produce exception, this line must be put after.
+                shared_query_id = state.query_id;
+
+                if (state.io.out)
+                    throw Exception("Insert query is not supported in shared query mode");
+            }
+            else
+            {
+                state.io = executeQuery(state.query, query_context, false, state.stage);
+            }
 
             if (state.io.out)
                 state.need_receive_data_for_insert = true;
@@ -170,6 +210,8 @@ void TCPHandler::runImpl()
             /// Does the request require receive data from client?
             if (state.need_receive_data_for_insert)
                 processInsertQuery(global_settings);
+            else if (!shared_query_id.empty())
+                processSharedQuery();
             else
                 processOrdinaryQuery();
 
@@ -216,6 +258,11 @@ void TCPHandler::runImpl()
             exception = std::make_unique<Exception>("Unknown exception", ErrorCodes::UNKNOWN_EXCEPTION);
         }
 
+        if (!shared_query_id.empty())
+        {
+            query_context.getSharedQueries()->onSharedQueryFinish(shared_query_id);
+        }
+
         try
         {
             if (exception)
@@ -230,6 +277,13 @@ void TCPHandler::runImpl()
 
         try
         {
+            // Manually call cancel before reset, as state.io.in is shared between clients in shared mode.
+            if (!shared_query_id.empty())
+            {
+                if (IProfilingBlockInputStream * input = dynamic_cast<IProfilingBlockInputStream *>(state.io.in.get()))
+                    input->cancel(true);
+            }
+
             state.reset();
         }
         catch (...)
@@ -244,7 +298,16 @@ void TCPHandler::runImpl()
         watch.stop();
 
         LOG_INFO(log, std::fixed << std::setprecision(3)
-            << "Processed in " << watch.elapsedSeconds() << " sec.");
+            << "Processed in " << watch.elapsedSeconds() << " sec. "
+            << "Global persisted cache hit|miss|busy|update: mark index files = "
+            << ProfileEvents::counters[ProfileEvents::PersistedMarksFileHits].load()
+            << "|" << ProfileEvents::counters[ProfileEvents::PersistedMarksFileMisses].load()
+            << "|" << ProfileEvents::counters[ProfileEvents::PersistedMarksFileBusy].load()
+            << "|" << ProfileEvents::counters[ProfileEvents::PersistedMarksFileUpdate].load()
+            << ", mark ranges = " << ProfileEvents::counters[ProfileEvents::PersistedCacheHits].load()
+            << "|" << ProfileEvents::counters[ProfileEvents::PersistedCacheMisses].load()
+            << "|" << ProfileEvents::counters[ProfileEvents::PersistedCacheBusy].load()
+            << "|" << ProfileEvents::counters[ProfileEvents::PersistedCacheUpdate].load());
 
         if (network_error)
             break;
@@ -798,8 +861,6 @@ void TCPHandler::run()
     try
     {
         runImpl();
-
-        LOG_INFO(log, "Done processing connection.");
     }
     catch (Poco::Exception & e)
     {
@@ -814,4 +875,38 @@ void TCPHandler::run()
     }
 }
 
+
+void TCPHandler::processSharedQuery()
+{
+    /// Send header-block, to allow client to prepare output format for data to send.
+    {
+        Block header = state.io.in->getHeader();
+        if (header)
+            sendData(header);
+    }
+
+    state.io.in->readPrefix();
+
+    while (true)
+    {
+        Block block;
+        if (isQueryCancelled())
+        {
+            LOG_WARNING(log, "Cancel input stream");
+            if (IProfilingBlockInputStream * input = dynamic_cast<IProfilingBlockInputStream *>(state.io.in.get()))
+                input->cancel(true);
+        }
+        else
+        {
+            block = state.io.in->read();
+        }
+        sendData(block);
+        if (!block)
+            break;
+    }
+
+    state.io.in->readSuffix();
+    state.io.onFinish();
+}
+
 }
