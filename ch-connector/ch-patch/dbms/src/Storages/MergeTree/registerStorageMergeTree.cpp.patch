diff --git a/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp b/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp
index 4cdff05c2..03c2d479d 100644
--- a/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp
+++ b/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp
@@ -1,6 +1,7 @@
 #include <Storages/StorageFactory.h>
 #include <Storages/StorageMergeTree.h>
 #include <Storages/StorageReplicatedMergeTree.h>
+#include <Storages/MutableSupport.h>
 
 #include <Common/typeid_cast.h>
 #include <Common/OptimizedRegularExpression.h>
@@ -203,6 +204,23 @@ static void setGraphitePatternsFromConfig(const Context & context,
 }
 
 
+static String getMutableMergeTreeVerboseHelp()
+{
+    String help = R"(
+
+MutableMergeTree is a member of the MergeTree engine family.
+
+MutableMergeTree is slightly different from the others:
+- it only support non-replicated
+- it won't take a 'date' type column for partitioning, instead, it take a number as partition count (default = 16).
+
+Examples of creating a MutableMergeTree table:
+- Create Table ... MutableMergeTree((CounterID, EventDate), 8192)
+- Create Table ... MutableMergeTree(16, (CounterID, EventDate), 8192)
+)";
+    return help;
+}
+
 static String getMergeTreeVerboseHelp(bool is_extended_syntax)
 {
     String help = R"(
@@ -210,11 +228,11 @@ static String getMergeTreeVerboseHelp(bool is_extended_syntax)
 MergeTree is a family of storage engines.
 
 MergeTrees are different in two ways:
-- they may be replicated and non-replicated;
+- they may be replicated and non-replicated (except MutableMergeTree, it only support non-replicated);
 - they may do different actions on merge: nothing; sign collapse; sum; apply aggregete functions.
 
-So we have 14 combinations:
-    MergeTree, CollapsingMergeTree, SummingMergeTree, AggregatingMergeTree, ReplacingMergeTree, GraphiteMergeTree, VersionedCollapsingMergeTree
+So we have 15 combinations:
+    MergeTree, CollapsingMergeTree, SummingMergeTree, AggregatingMergeTree, ReplacingMergeTree, GraphiteMergeTree, VersionedCollapsingMergeTree, MutableMergeTree
     ReplicatedMergeTree, ReplicatedCollapsingMergeTree, ReplicatedSummingMergeTree, ReplicatedAggregatingMergeTree, ReplicatedReplacingMergeTree, ReplicatedGraphiteMergeTree, ReplicatedVersionedCollapsingMergeTree
 
 In most of cases, you need MergeTree or ReplicatedMergeTree.
@@ -368,6 +386,8 @@ static StoragePtr create(const StorageFactory::Arguments & args)
         merging_params.mode = MergeTreeData::MergingParams::Aggregating;
     else if (name_part == "Replacing")
         merging_params.mode = MergeTreeData::MergingParams::Replacing;
+    else if (name_part == "Mutable")
+        merging_params.mode = MergeTreeData::MergingParams::Mutable;
     else if (name_part == "Graphite")
         merging_params.mode = MergeTreeData::MergingParams::Graphite;
     else if (name_part == "VersionedCollapsing")
@@ -377,6 +397,8 @@ static StoragePtr create(const StorageFactory::Arguments & args)
             "Unknown storage " + args.engine_name + getMergeTreeVerboseHelp(is_extended_storage_def),
             ErrorCodes::UNKNOWN_STORAGE);
 
+    bool is_mutable_engine = (merging_params.mode == MergeTreeData::MergingParams::Mutable);
+
     /// NOTE Quite complicated.
 
     size_t min_num_params = 0;
@@ -393,7 +415,7 @@ static StoragePtr create(const StorageFactory::Arguments & args)
     auto add_optional_param = [&](const char * desc)
     {
         ++max_num_params;
-        needed_params += needed_params.empty() ? "\n" : ",\n[";
+        needed_params += needed_params.empty() ? "\n[" : ",\n[";
         needed_params += desc;
         needed_params += "]";
     };
@@ -404,7 +426,13 @@ static StoragePtr create(const StorageFactory::Arguments & args)
         add_mandatory_param("replica name");
     }
 
-    if (!is_extended_storage_def)
+    if (is_mutable_engine)
+    {
+        add_optional_param("partition number");
+        add_mandatory_param("primary key expression");
+        add_mandatory_param("index granularity");
+    }
+    else if (!is_extended_storage_def)
     {
         add_mandatory_param("name of column with date");
         add_optional_param("sampling element of primary key");
@@ -457,7 +485,7 @@ static StoragePtr create(const StorageFactory::Arguments & args)
         else
             msg += "no parameters";
 
-        msg += getMergeTreeVerboseHelp(is_extended_storage_def);
+        msg += is_mutable_engine ? getMutableMergeTreeVerboseHelp() : getMergeTreeVerboseHelp(is_extended_storage_def);
 
         throw Exception(msg, ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
     }
@@ -494,6 +522,8 @@ static StoragePtr create(const StorageFactory::Arguments & args)
 
     ASTPtr secondary_sorting_expr_list;
 
+    auto columns = args.columns;
+
     if (merging_params.mode == MergeTreeData::MergingParams::Collapsing)
     {
         if (auto ast = typeid_cast<const ASTIdentifier *>(engine_args.back().get()))
@@ -520,6 +550,16 @@ static StoragePtr create(const StorageFactory::Arguments & args)
             engine_args.pop_back();
         }
     }
+    else if (merging_params.mode == MergeTreeData::MergingParams::Mutable)
+    {
+        // Add version column and del-mark column, set to engine params.
+        const Names & names = args.columns.getNamesOfPhysical();
+        if (std::find(names.begin(), names.end(), MutableSupport::version_column_name) == names.end())
+            columns.ordinary.push_back(NameAndTypePair(MutableSupport::version_column_name, std::make_shared<DataTypeUInt64>()));
+        if (std::find(names.begin(), names.end(), MutableSupport::delmark_column_name) == names.end())
+            columns.ordinary.push_back(NameAndTypePair(MutableSupport::delmark_column_name, std::make_shared<DataTypeUInt8>()));
+        merging_params.version_column = MutableSupport::version_column_name;
+    }
     else if (merging_params.mode == MergeTreeData::MergingParams::Summing)
     {
         /// If the last element is not index_granularity or replica_name (a literal), then this is a list of summable columns.
@@ -596,6 +636,30 @@ static StoragePtr create(const StorageFactory::Arguments & args)
 
         storage_settings.loadFromQuery(*args.storage_def);
     }
+    else if (is_mutable_engine)
+    {
+        if (engine_args.size() == 3)
+        {
+            auto ast = typeid_cast<const ASTLiteral *>(engine_args[0].get());
+            if (ast && ast->value.getType() == Field::Types::UInt64)
+                storage_settings.mutable_mergetree_partition_number = safeGet<UInt64>(ast->value);
+            else
+                throw Exception(
+                    "Partition number  must be a positive integer" + getMutableMergeTreeVerboseHelp(),
+                    ErrorCodes::BAD_ARGUMENTS);
+            engine_args.erase(engine_args.begin());
+        }
+
+        primary_expr_list = extractKeyExpressionList(*engine_args[0]);
+
+        auto ast = typeid_cast<const ASTLiteral *>(engine_args[1].get());
+        if (ast && ast->value.getType() == Field::Types::UInt64)
+            storage_settings.index_granularity = safeGet<UInt64>(ast->value);
+        else
+            throw Exception(
+                "Index granularity must be a positive integer" + getMutableMergeTreeVerboseHelp(),
+                ErrorCodes::BAD_ARGUMENTS);
+    }
     else
     {
         /// If there is an expression for sampling. MergeTree(date, [sample_key], primary_key, index_granularity)
@@ -628,13 +692,13 @@ static StoragePtr create(const StorageFactory::Arguments & args)
     if (replicated)
         return StorageReplicatedMergeTree::create(
             zookeeper_path, replica_name, args.attach, args.data_path, args.database_name, args.table_name,
-            args.columns,
+            columns,
             args.context, primary_expr_list, secondary_sorting_expr_list, date_column_name, partition_expr_list,
             sampling_expression, merging_params, storage_settings,
             args.has_force_restore_data_flag);
     else
         return StorageMergeTree::create(
-            args.data_path, args.database_name, args.table_name, args.columns, args.attach,
+            args.data_path, args.database_name, args.table_name, columns, args.attach,
             args.context, primary_expr_list, secondary_sorting_expr_list, date_column_name, partition_expr_list,
             sampling_expression, merging_params, storage_settings,
             args.has_force_restore_data_flag);
@@ -646,6 +710,7 @@ void registerStorageMergeTree(StorageFactory & factory)
     factory.registerStorage("MergeTree", create);
     factory.registerStorage("CollapsingMergeTree", create);
     factory.registerStorage("ReplacingMergeTree", create);
+    factory.registerStorage(MutableSupport::storage_name, create);
     factory.registerStorage("AggregatingMergeTree", create);
     factory.registerStorage("SummingMergeTree", create);
     factory.registerStorage("GraphiteMergeTree", create);
@@ -654,6 +719,7 @@ void registerStorageMergeTree(StorageFactory & factory)
     factory.registerStorage("ReplicatedMergeTree", create);
     factory.registerStorage("ReplicatedCollapsingMergeTree", create);
     factory.registerStorage("ReplicatedReplacingMergeTree", create);
+    // factory.registerStorage("Replicated" + MutableSupport::storage_name, create);
     factory.registerStorage("ReplicatedAggregatingMergeTree", create);
     factory.registerStorage("ReplicatedSummingMergeTree", create);
     factory.registerStorage("ReplicatedGraphiteMergeTree", create);
