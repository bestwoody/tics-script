diff --git a/dbms/src/Storages/StorageMergeTree.cpp b/dbms/src/Storages/StorageMergeTree.cpp
index 7e0c703..2f9e742 100644
--- a/dbms/src/Storages/StorageMergeTree.cpp
+++ b/dbms/src/Storages/StorageMergeTree.cpp
@@ -15,6 +15,15 @@
 #include <Storages/MergeTree/MergeTreeData.h>
 #include <Storages/MergeTree/ActiveDataPartSet.h>
 
+#include <Storages/MutableSupport.h>
+#include <Parsers/ASTInsertQuery.h>
+#include <Parsers/ASTDeleteQuery.h>
+
+#include <DataStreams/mergeMutableBlockInputStreams.h>
+#include <DataStreams/RemoveColumnsBlockInputStream.h>
+#include <DataStreams/AdditionalColumnsBlockOutputStream.h>
+#include <DataStreams/DedupSortedBlockInputStream.h>
+
 #include <Poco/DirectoryIterator.h>
 #include <Poco/File.h>
 
@@ -114,12 +123,94 @@ BlockInputStreams StorageMergeTree::read(
     const size_t max_block_size,
     const unsigned num_streams)
 {
-    return reader.read(column_names, query_info, context, processed_stage, max_block_size, num_streams, 0);
+    auto res = reader.read(column_names, query_info, context, processed_stage, max_block_size, num_streams, 0);
+
+    const ASTSelectQuery * select_query = typeid_cast<const ASTSelectQuery *>(&*query_info.query);
+
+    if (data.merging_params.mode == MergeTreeData::MergingParams::Mutable)
+    {
+        if (select_query && !select_query->raw_for_mutable)
+        {
+            LOG_DEBUG(log, "Mutable table dedup read.");
+            res = mergeMutableBlockInputStreams(res, data.getSortDescription(),
+                MutableSupport::version_column_name, max_block_size, MutableSupport::pipeline_dedup_calculator);
+
+            Names filtered_names;
+            filtered_names.push_back(MutableSupport::version_column_name);
+            filtered_names.push_back(MutableSupport::delmark_column_name);
+            BlockInputStreams filtered(res.size());
+            for (size_t i = 0; i < res.size(); ++i)
+                filtered[i] = std::make_shared<RemoveColumnsBlockInputStream>(res[i], filtered_names);
+            res = filtered;
+        }
+        else
+            LOG_DEBUG(log, "Mutable table raw read.");
+    }
+    else if (select_query && select_query->raw_for_mutable)
+    {
+        throw Exception("Only " + MutableSupport::storage_name + " support SELRAW.", ErrorCodes::BAD_ARGUMENTS);
+    }
+    return res;
 }
 
-BlockOutputStreamPtr StorageMergeTree::write(const ASTPtr & /*query*/, const Settings & /*settings*/)
+UInt64 StorageMergeTree::getVersionSeed(const Settings & /* settings */) const
 {
-    return std::make_shared<MergeTreeBlockOutputStream>(*this);
+    // NOTE:
+    // We don't guarantee thread safe.
+    // In that case, we assume data not related in diffent thread.
+    // So we can use the same version number.
+    //
+    // WARNING: NOT safe in distribed mode.
+
+    // TODO:
+    // It's faster if we use (increment.value << 32).
+    // We use '* 1000000' for readable results, just for now
+    return (increment.value + 1) * 1000000;
+}
+
+BlockOutputStreamPtr StorageMergeTree::write(const ASTPtr & query, const Settings & settings)
+{
+    BlockOutputStreamPtr res = std::make_shared<MergeTreeBlockOutputStream>(*this);
+
+    const ASTInsertQuery * insert_query = typeid_cast<const ASTInsertQuery *>(&*query);
+    const ASTDeleteQuery * delete_query = typeid_cast<const ASTDeleteQuery *>(&*query);
+
+    if (data.merging_params.mode == MergeTreeData::MergingParams::Mutable)
+    {
+        if (insert_query)
+        {
+            if (!insert_query->is_import)
+            {
+                LOG_DEBUG(log, "Mutable table writing, add version column and del-mark column.");
+                AdditionalBlockGenerators gens
+                {
+                    std::make_shared<AdditionalBlockGeneratorIncrease<UInt64>>(MutableSupport::version_column_name,
+                        getVersionSeed(settings)),
+                    std::make_shared<AdditionalBlockGeneratorConst<UInt8>>(MutableSupport::delmark_column_name, 0)
+                };
+                res = std::make_shared<AdditionalColumnsBlockOutputStream>(res, gens);
+            }
+            else
+                LOG_DEBUG(log, "Mutable table importing.");
+        }
+        else if (delete_query)
+        {
+            LOG_DEBUG(log, "Mutable table deleting.");
+            AdditionalBlockGenerators gens
+            {
+                std::make_shared<AdditionalBlockGeneratorConst<UInt64>>(MutableSupport::version_column_name,
+                    getVersionSeed(settings)),
+                std::make_shared<AdditionalBlockGeneratorConst<UInt8>>(MutableSupport::delmark_column_name, 1)
+            };
+            res = std::make_shared<AdditionalColumnsBlockOutputStream>(res, gens);
+        }
+    }
+    else if ((insert_query && insert_query->is_import) || delete_query)
+    {
+        throw Exception("Only " + MutableSupport::storage_name + " support IMPORT or DELETE.", ErrorCodes::BAD_ARGUMENTS);
+    }
+
+    return res;
 }
 
 bool StorageMergeTree::checkTableCanBeDropped() const
@@ -129,6 +220,11 @@ bool StorageMergeTree::checkTableCanBeDropped() const
     return true;
 }
 
+const OrderedNameSet & StorageMergeTree::getHiddenColumnsImpl() const
+{
+    return MutableSupport::instance().hiddenColumns(getName());
+}
+
 void StorageMergeTree::drop()
 {
     shutdown();
