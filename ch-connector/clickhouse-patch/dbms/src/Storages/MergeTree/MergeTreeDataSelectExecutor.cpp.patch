diff --git a/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
index 1766f60..5c78972 100644
--- a/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
+++ b/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
@@ -7,10 +7,14 @@
 #include <Storages/MergeTree/MergeTreeReadPool.h>
 #include <Storages/MergeTree/MergeTreeThreadBlockInputStream.h>
 #include <Storages/MergeTree/PKCondition.h>
+
 #include <Parsers/ASTIdentifier.h>
 #include <Parsers/ASTFunction.h>
 #include <Parsers/ASTSampleRatio.h>
 
+#include <Common/Stopwatch.h>
+
+
 /// Allow to use __uint128_t as a template parameter for boost::rational.
 // https://stackoverflow.com/questions/41198673/uint128-t-not-working-with-clang-and-libstdc
 #if !defined(__GLIBCXX_BITSIZE_INT_N_0) && defined(__SIZEOF_INT128__)
@@ -43,6 +47,10 @@ namespace std
 #include <DataTypes/DataTypeEnum.h>
 #include <Storages/VirtualColumnUtils.h>
 
+#include <Storages/MutableSupport.h>
+#include <DataStreams/ExtraHeadTailBlockInputStream.h>
+#include <DataStreams/ReplacingDeletingSortedBlockInputStream.h>
+
 
 namespace ProfileEvents
 {
@@ -138,8 +146,6 @@ BlockInputStreams MergeTreeDataSelectExecutor::read(
     const unsigned num_streams,
     Int64 max_block_number_to_read) const
 {
-    size_t part_index = 0;
-
     MergeTreeData::DataPartsVector parts = data.getDataPartsVector();
 
     /// If query contains restrictions on the virtual column `_part` or `_part_index`, select only parts suitable for it.
@@ -510,43 +516,45 @@ BlockInputStreams MergeTreeDataSelectExecutor::read(
             CreatingSetsBlockInputStream(std::make_shared<NullBlockInputStream>(), prewhere_subqueries, settings.limits).read();
     }
 
-    RangesInDataParts parts_with_ranges;
+    bool is_mutable_engine = (data.merging_params.mode == MergeTreeData::MergingParams::Mutable && !select.raw_for_mutable);
 
-    /// Let's find what range to read from each part.
-    size_t sum_marks = 0;
-    size_t sum_ranges = 0;
-    for (auto & part : parts)
+    RangesInDataParts parts_with_ranges;
+    if (!is_mutable_engine)
     {
-        RangesInDataPart ranges(part, part_index++);
-
-        if (data.merging_params.mode != MergeTreeData::MergingParams::Unsorted)
-            ranges.ranges = markRangesFromPKRange(part->index, key_condition, settings);
-        else
-            ranges.ranges = MarkRanges{MarkRange{0, part->marks_count}};
-
-        if (!ranges.ranges.empty())
-        {
-            parts_with_ranges.push_back(ranges);
-
-            sum_ranges += ranges.ranges.size();
-            for (const auto & range : ranges.ranges)
-                sum_marks += range.end - range.begin;
-        }
+        getPartsWithRanges(parts, key_condition, settings, parts_with_ranges);
+        if (parts_with_ranges.empty())
+            return {};
     }
 
-    LOG_DEBUG(log, "Selected " << parts.size() << " parts by date, " << parts_with_ranges.size() << " parts by key, "
-        << sum_marks << " marks to read from " << sum_ranges << " ranges");
+    BlockInputStreams res;
 
-    if (parts_with_ranges.empty())
-        return {};
+    if (is_mutable_engine)
+    {
+        column_names_to_read.insert(column_names_to_read.end(), MutableSupport::version_column_name);
+        column_names_to_read.insert(column_names_to_read.end(), MutableSupport::delmark_column_name);
 
-    ProfileEvents::increment(ProfileEvents::SelectedParts, parts_with_ranges.size());
-    ProfileEvents::increment(ProfileEvents::SelectedRanges, sum_ranges);
-    ProfileEvents::increment(ProfileEvents::SelectedMarks, sum_marks);
+        std::vector<String> add_columns = data.getPrimaryExpression()->getRequiredColumns();
+        column_names_to_read.insert(column_names_to_read.end(), add_columns.begin(), add_columns.end());
 
-    BlockInputStreams res;
+        std::sort(column_names_to_read.begin(), column_names_to_read.end());
+        column_names_to_read.erase(std::unique(column_names_to_read.begin(), column_names_to_read.end()), column_names_to_read.end());
 
-    if (select.final())
+        res = spreadMarkRangesAmongStreamsOnMutableEngine(
+            parts,
+            key_condition,
+            column_names_to_read,
+            max_block_size,
+            num_streams,
+            settings.use_uncompressed_cache,
+            prewhere_actions,
+            prewhere_column,
+            virt_column_names,
+            settings);
+
+        if (res.size() == 0)
+            return res;
+    }
+    else if (select.final())
     {
         /// Add columns needed to calculate primary key and the sign.
         std::vector<String> add_columns = data.getPrimaryExpression()->getRequiredColumns();
@@ -741,6 +749,7 @@ BlockInputStreams MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreams(
     return res;
 }
 
+
 BlockInputStreams MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsFinal(
     RangesInDataParts && parts,
     const Names & column_names,
@@ -823,6 +832,9 @@ BlockInputStreams MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsFinal
                     data.getSortDescription(), data.merging_params.version_column, max_block_size);
                 break;
 
+            case MergeTreeData::MergingParams::Mutable:
+                throw Exception("MutableMergeTree doesn't handle here", ErrorCodes::LOGICAL_ERROR);
+
             case MergeTreeData::MergingParams::Unsorted:
                 throw Exception("UnsortedMergeTree doesn't support FINAL", ErrorCodes::LOGICAL_ERROR);
 
@@ -837,6 +849,172 @@ BlockInputStreams MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsFinal
 }
 
 
+BlockInputStreams MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsOnMutableEngine(
+    MergeTreeData::DataPartsVector & parts,
+    const PKCondition & key_condition,
+    const Names & column_names,
+    size_t max_block_size,
+    unsigned num_streams,
+    bool use_uncompressed_cache,
+    ExpressionActionsPtr prewhere_actions,
+    const String & prewhere_column,
+    const Names & virt_columns,
+    const Settings & settings) const
+{
+    RangesInDataParts parts_with_ranges;
+    size_t sum_marks = 0;
+    getPartsWithRanges(parts, key_condition, settings, parts_with_ranges, &sum_marks);
+
+    const size_t max_marks_to_use_cache =
+        (settings.merge_tree_max_rows_to_use_cache + data.index_granularity - 1) / data.index_granularity;
+    if (sum_marks > max_marks_to_use_cache)
+        use_uncompressed_cache = false;
+
+    // TODO: Implement: split parts to sections
+    // TODO: If data is small enough, use simple DedupSorted
+    {
+        Stopwatch watch;
+        const size_t min_marks_for_concurrent_read =
+            (settings.merge_tree_min_rows_for_concurrent_read + data.index_granularity - 1) / data.index_granularity;
+        if (sum_marks < num_streams * min_marks_for_concurrent_read && parts.size() < num_streams)
+            num_streams = std::max((sum_marks + min_marks_for_concurrent_read - 1) / min_marks_for_concurrent_read, parts.size());
+
+        size_t each_section_marks = (sum_marks + num_streams / 2) / num_streams;
+        size_t marks_increase_step = std::max(each_section_marks / 16, 1);
+
+        LOG_DEBUG(log, "Each section marks: " << each_section_marks << ", splitting increase step " << marks_increase_step);
+
+        struct SplittedPartStream
+        {
+            RangesInDataPart gathered_ranges_in_part;
+            Block extra_head;
+            Block extra_tail;
+        };
+
+        using SplittedSortingStream = std::vector<SplittedPartStream>;
+
+        ///*
+        std::vector<SplittedSortingStream> splitted_sorting_streams;
+
+        SplittedSortingStream curr_gathering(parts_with_ranges.size());
+        for (size_t i = 0; i < parts_with_ranges.size(); ++i)
+            curr_gathering[i].gathered_ranges_in_part =
+                RangesInDataPart(parts_with_ranges[i].data_part, parts_with_ranges[i].part_index_in_query);
+
+        size_t num_ranges_in_curr_section = 0;
+
+        struct RangeCursor
+        {
+            RangesInDataPart * ranges_in_part;
+            size_t range_index;
+
+            // Base 0, not MarkRange.begin
+            size_t mark_index;
+
+            // TODO: Impliment: compare part index value of cursor right bound.
+            bool operator < (const RangeCursor & rhs) const
+            {
+                return ranges_in_part->part_index_in_query < rhs.ranges_in_part->part_index_in_query;
+            }
+        };
+
+        std::priority_queue<RangeCursor> ranges_queue;
+
+        for (size_t i = 0; i < parts_with_ranges.size(); ++i)
+            ranges_queue.push(RangeCursor{&parts_with_ranges[i], 0, 0});
+
+        while (!ranges_queue.empty())
+        {
+            RangeCursor cursor = ranges_queue.top();
+            ranges_queue.pop();
+
+            auto & gathering_part = curr_gathering[cursor.ranges_in_part->part_index_in_query];
+            auto & gathering_ranges = gathering_part.gathered_ranges_in_part.ranges;
+            auto & splitting_range = cursor.ranges_in_part->ranges[cursor.range_index];
+
+            size_t increase_step = std::min(splitting_range.end - splitting_range.begin - cursor.mark_index, marks_increase_step);
+
+            MarkRange range{splitting_range.begin + cursor.mark_index, splitting_range.begin + cursor.mark_index + increase_step};
+
+            // TODO: Check/Read/Split the block cross bound
+
+            gathering_ranges.emplace_back(range);
+            num_ranges_in_curr_section += increase_step;
+
+            if (num_ranges_in_curr_section >= each_section_marks && splitted_sorting_streams.size() < num_streams)
+            {
+                splitted_sorting_streams.emplace_back(curr_gathering);
+                curr_gathering = SplittedSortingStream(parts_with_ranges.size());
+                for (size_t i = 0; i < parts_with_ranges.size(); ++i)
+                    curr_gathering[i].gathered_ranges_in_part =
+                        RangesInDataPart(parts_with_ranges[i].data_part, parts_with_ranges[i].part_index_in_query);
+            }
+
+            cursor.mark_index += increase_step;
+            if (cursor.mark_index < splitting_range.end - splitting_range.begin)
+            {
+                ranges_queue.push(cursor);
+            }
+            else
+            {
+                cursor.range_index += 1;
+                cursor.mark_index = 0;
+                if (cursor.range_index < cursor.ranges_in_part->ranges.size())
+                    ranges_queue.push(cursor);
+            }
+        }
+
+        splitted_sorting_streams.emplace_back(curr_gathering);
+
+        const SortDescription & description = data.getSortDescription();
+
+        BlockInputStreams res;
+        for (auto & splitted_parts : splitted_sorting_streams)
+        {
+            BlockInputStreams part_streams;
+            for (auto & splitted_part : splitted_parts)
+            {
+                BlockInputStreamPtr part_stream = std::make_shared<MergeTreeBlockInputStream>(
+                    data, splitted_part.gathered_ranges_in_part.data_part, max_block_size, settings.preferred_block_size_bytes,
+                    settings.preferred_max_column_in_block_size_bytes, column_names, splitted_part.gathered_ranges_in_part.ranges,
+                    use_uncompressed_cache, prewhere_actions, prewhere_column, true, settings.min_bytes_to_use_direct_io,
+                    settings.max_read_buffer_size, true, virt_columns, splitted_part.gathered_ranges_in_part.part_index_in_query);
+                part_stream = std::make_shared<ExtraHeadTailBlockInputStream>(part_stream, description,
+                    splitted_part.extra_head, splitted_part.extra_tail);
+                // TODO: Remove it?
+                part_streams.emplace_back(std::make_shared<ExpressionBlockInputStream>(part_stream, data.getPrimaryExpression()));
+            }
+            res.emplace_back(std::make_shared<ReplacingDeletingSortedBlockInputStream>(part_streams, description,
+                MutableSupport::version_column_name, MutableSupport::delmark_column_name, DEFAULT_MERGE_BLOCK_SIZE, nullptr, false, true));
+        }
+        //*/
+
+        watch.stop();
+        LOG_INFO(log, std::fixed << std::setprecision(3) << "Create reading plan in " << watch.elapsedSeconds() << " sec.");
+
+        //return res;
+    }
+
+    // Origin reading
+    {
+        BlockInputStreams res;
+        for (size_t part_index = 0; part_index < parts_with_ranges.size(); ++part_index)
+        {
+            RangesInDataPart & part = parts_with_ranges[part_index];
+
+            BlockInputStreamPtr source_stream = std::make_shared<MergeTreeBlockInputStream>(
+                data, part.data_part, max_block_size, settings.preferred_block_size_bytes,
+                settings.preferred_max_column_in_block_size_bytes, column_names, part.ranges, use_uncompressed_cache,
+                prewhere_actions, prewhere_column, true, settings.min_bytes_to_use_direct_io, settings.max_read_buffer_size, true,
+                virt_columns, part.part_index_in_query);
+
+            res.emplace_back(std::make_shared<ExpressionBlockInputStream>(source_stream, data.getPrimaryExpression()));
+        }
+        return res;
+    }
+}
+
+
 void MergeTreeDataSelectExecutor::createPositiveSignCondition(
     ExpressionActionsPtr & out_expression, String & out_column, const Context & context) const
 {
@@ -948,4 +1126,45 @@ MarkRanges MergeTreeDataSelectExecutor::markRangesFromPKRange(
     return res;
 }
 
+
+void MergeTreeDataSelectExecutor::getPartsWithRanges(MergeTreeData::DataPartsVector & parts, const PKCondition & key_condition,
+    const Settings & settings, RangesInDataParts & parts_with_ranges, size_t * out_sum_marks) const
+{
+    size_t part_index = 0;
+    size_t sum_marks = 0;
+    size_t sum_ranges = 0;
+
+    for (auto & part : parts)
+    {
+        RangesInDataPart ranges(part, part_index++);
+
+        if (data.merging_params.mode != MergeTreeData::MergingParams::Unsorted)
+            ranges.ranges = markRangesFromPKRange(part->index, key_condition, settings);
+        else
+            ranges.ranges = MarkRanges{MarkRange{0, part->marks_count}};
+
+        if (!ranges.ranges.empty())
+        {
+            parts_with_ranges.push_back(ranges);
+
+            sum_ranges += ranges.ranges.size();
+            for (const auto & range : ranges.ranges)
+                sum_marks += range.end - range.begin;
+        }
+    }
+
+    if (out_sum_marks)
+        *out_sum_marks = sum_marks;
+
+    LOG_DEBUG(log, "Selected " << parts.size() << " parts by date, " << parts_with_ranges.size() << " parts by key, "
+        << sum_marks << " marks to read from " << sum_ranges << " ranges");
+
+    if (parts_with_ranges.empty())
+        return;
+
+    ProfileEvents::increment(ProfileEvents::SelectedParts, parts_with_ranges.size());
+    ProfileEvents::increment(ProfileEvents::SelectedRanges, sum_ranges);
+    ProfileEvents::increment(ProfileEvents::SelectedMarks, sum_marks);
+}
+
 }
